<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="alternate" href="/rss.xml" title="Lystics" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Lystics" type="application/atom+xml"><link rel="alternate" type="application/json" title="Lystics" href="https://lysistic.github.io/feed.json"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" media="none" onload="this.media='all'"><link rel="stylesheet" href="/css/app.css?v=0.4.2"><link rel="modulepreload" href="/js/chunk-AHWQPRSO.js"><link rel="modulepreload" href="/js/chunk-D5E3HCIM.js"><link rel="modulepreload" href="/js/chunk-QAWHJ5B3.js"><link rel="modulepreload" href="/js/index.esm-KMEAF737.js"><link rel="modulepreload" href="/js/post-VSW2ZODR.js"><link rel="modulepreload" href="/js/quicklink-L7SCP7EH.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="preload" href="https://lysistic.github.io/image/img/img(25).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(41).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(39).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(81).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(33).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(71).webp" as="image" fetchpriority="high"><link rel="canonical" href="https://lysistic.github.io/2024/03/04/number-theory/"><title>number_theory</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">number_theory</h1><div class="meta"><span class="item" title="Created: 2024-03-04 08:54:19"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">Posted on</span><time itemprop="dateCreated datePublished" datetime="2024-03-04T08:54:19+08:00">2024-03-04</time></span><span class="item" title="Symbols count in article"><span class="icon"><i class="ic i-pen"></i></span><span class="text">Symbols count in article</span><span>29k</span><span class="text">words</span></span><span class="item" title="Reading time"><span class="icon"><i class="ic i-clock"></i></span><span class="text">Reading time</span><span>27 mins.</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="Toggle navigation bar"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hust_CSE_undergraduate</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(25).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(41).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(39).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(81).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(33).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(71).webp&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement="" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">Home</a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh"><link itemprop="mainEntityOfPage" href="https://lysistic.github.io/2024/03/04/number-theory/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="lystics"><meta itemprop="description" content=", "></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Lystics"></span><div class="body md" itemprop="articleBody"><p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304085613751.png" alt="image-20240304085613751"></p>
<ul>
<li>b 可被 a 整除，b 是 a 的倍数，a 是 b 的因子。</li>
</ul>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304090047739.png" alt="image-20240304090047739"></p>
<ul>
<li>两数满足整除关系，正负绝对值之间都满足，整除是数值大小上的一种特性</li>
<li>a 是 b 的因子，b 是 c 的因子，a 自然是 ca 的因子</li>
<li>a 是 b 的因子的同时 a 是 c 的因子，所以 a 是 b 和 c 的任意线性组合的因子</li>
<li>a 整除 b 的同时 b 整除 a，那么 a 和 b 的绝对值相等</li>
<li>如果 a 整除 b，a 和 b 的非零倍数也满足关系</li>
<li>a|b,b 是否等于零是一个特殊情况，如果 b 不等于零，那么 a 的绝对值小于等于 b 的绝对值。也就是说 a|b，要么 b 等于零 a 的绝对值大于等于 b，要么 a 的绝对值小于等于 b</li>
<li>如果 a 不等于 0，a 不能整除 b，也就是说 b 等于 a 的某个倍数加上一个余数 c，那么 a|b=a|c, 也就是 b 和 c 在模 a 下同余</li>
<li>a|b,b 是 a 的倍数，a 是 b 的约数</li>
<li>0 是所有非零整数的倍数，非零倍数的约束是有限个，且一定可以写成不同个质数的某幂次的积</li>
<li>平凡约数，对于一个不为零的整数 b，+1，-1，+b，-b 是其平凡约数，b 的其他约数称为真约数</li>
<li><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304093544500.png" alt="image-20240304093544500"></li>
</ul>
<p>约数描述的关系是相互的，这是一个闭包，也就是从前到后和从后到前，所以缩小复杂度可以从根号处判断</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304093720894.png" alt="image-20240304093720894"></p>
<p>带余数的除法，这里的余数不是我们理解的那个除不尽的余数，这个就是字面意思上的一个平移补充项。余数为 r，这里说 b 可以描述为 a 的多少倍，r 是 b 和 a 的 q 倍的差值。自然的可以想到 r 可以描述为 ma+r0. 无论整数 d 取多少，都能找到余数 r，也就是说保证余数 r 在 d 到 a+d 之间。因为 r0+ka，不断遍历 k 找到第一个大于 d 的数就行了。</p>
<p>无论 d 取多少，这么说吧 b 和 r 在模 a 的意义下同余。</p>
<p>绝对最小余数，d 取 a 绝对值一半的相反数。那么这个余数就在</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304102755600.png" alt="image-20240304102755600"></p>
<p>当 d 取零时，就是我们一般意义下的带余除法，这里的余数 r 称为最小非负余数</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304103003557.png" alt="image-20240304103003557"></p>
<p>带余除法的性质</p>
<ul>
<li>
<p>任一整数被正整数 a 除后，余数一定是且仅是 0 到 a-1 这 a 个数中的一个</p>
</li>
<li>
<p>相邻的 a 个整数被正整数 a 除后，恰好取到上述 a 个余数，特别的，一定有且仅有一个数被 a 整除。（区间唯一性）</p>
</li>
<li>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304103545996.png" alt="image-20240304103545996"></p>
</li>
</ul>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304103607016.png" alt="image-20240304103607016"></p>
<p>设整数 p 不等于 0，正负 1，如果 p 除了平凡约束意外没有其他约数，那么称 p 为素数。（不可约数）</p>
<p>a 不是素数，则称 a 为合数</p>
<p>素数与合数的简单性质</p>
<p>合数可以描述为两个整数的乘积</p>
<p>对于合数 a 一定存在素数 p<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><msqrt><mi>a</mi></msqrt></mrow><annotation encoding="application/x-tex">\leq\sqrt{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">a</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>​</p>
<p>如果有大于 1 的约数，那么这个约数是他自己</p>
<p>合数一定可以分解为若干个质数</p>
<p>素数有无穷多个</p>
<p>所有大于 3 的素数都可以表示为 6n+1 的形式</p>
<p>算数基本引理，p 整除 a1a2，那么 p 一定是 a1 的约数或者 a2 的约数</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304105843977.png" alt="image-20240304105843977"></p>
<p>标准素数分解式</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304110122252.png" alt="image-20240304110122252"></p>
<p>b 是 a 模 m 的剩余</p>
<p>最小非负剩余，绝对最小剩余，最小正剩余</p>
<p>同余的性质：</p>
<p>自反性、对称性、传递性，以及支持线性运算不变性</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304115412271.png" alt="image-20240304115412271"></p>
<hr>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304115539249.png" alt="image-20240304115539249"></p>
<p>相对复杂，限制更强</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080724341.png" alt="image-20240305080724341"><br>
 更精细更小的生成元仍然满足</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080751971.png" alt="image-20240305080751971"></p>
<p>a 和 b 对 m 同余，那么 a 和 m 的最大公约数和 b 和 m 的最大公约数相等</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080837855.png" alt="image-20240305080837855"></p>
<p>d 能整除 m 且 d 能整除 a 和 b 中的一个 ----------&gt;d 能整除 a 和 b 中的另一个</p>
<p>积性函数</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080952566.png" alt="image-20240305080952566"></p>
<p>互质的满足乘法同态，当任意都满足则成为完全积性函数</p>
<ul>
<li><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305081145805.png" alt="image-20240305081145805"></li>
<li>完全积性的话自己和自己也能拆，就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo>∗</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>f</mi><mn>2</mn></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x*x)=f(x)*f(x)=f^2(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>素数记数函数，小于或等于 x 的素数的个数，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 来表示，随着其增大，近似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>x</mi><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{x}{ln(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2154em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">n</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight">x</span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<pre><code>def isPrime(a):
    if a &lt; 2:
        return False
    for i in range(2, a):
        if a % i == 0:
            return False
    return True
</code></pre>
<p>暴力做法直接枚举</p>
<p>不难发现检验 [2,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>a</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">a</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>] 内的数就可以</p>
<p>素性测试有两种，确定性测试和概率性测试，常见的包括 Lucas-Lehmer 测试和椭圆曲线素性证明。</p>
<p>概率性测试：通常比确定性测试快很多，但有可能寄，通过概率性测试的数字被称为可能素数，而通过确定性测试的合数被称为伪素数，最常见的类型是费马伪素数。概率性测试的常见事例包括 Miller-Rabin 测试</p>
<p>Fermat 素性测试</p>
<p>Fermat 素性检验是一种简单的概率素性检验</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082141914.png" alt="image-20240305082141914"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082223623.png" alt="image-20240305082223623"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082309065.png" alt="image-20240305082309065"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082357670.png" alt="image-20240305082357670"></p>
<p><strong>Miller–Rabin 素性测试</strong>（Miller–Rabin primality test）是进阶的素数判定方法。它是由 Miller 和 Rabin 二人根据费马小定理的逆定理（费马测试）优化得到的。因为和许多类似算法一样，它是使用伪素数的概率性测试，我们必须使用慢得多的确定性算法来保证素性。然而，实际上没有已知的数字通过了高级概率性测试（例如 Miller–Rabin）但实际上却是复合的。因此我们可以放心使用。</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082511735.png" alt="image-20240305082511735"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305083007839.png" alt="image-20240305083007839"></p>
<p>除了之前提到的性质外，卡迈尔数还有一些其他的数学性质：</p>
<ol>
<li><strong>平方数性质：</strong> 卡迈尔数不能是平方数。因为如果一个数是平方数，那么它的所有质因数的指数都是偶数，这与卡迈尔数的定义相矛盾。</li>
<li><strong>半素数性质：</strong> 卡迈尔数不能是半素数，即不能表示为两个不同素数的乘积。这是因为如果一个数是半素数，它的所有质因数的指数都是 1，而卡迈尔数的质因数必须至少有一个指数大于 1，以满足费马小定理。</li>
<li><strong>孪生卡迈尔数：</strong> 存在一些卡迈尔数的 “孪生对”，即两个卡迈尔数相差一个数。这类似于孪生素数对，但卡迈尔数的孪生对相对稀有得多。</li>
<li><strong>连续卡迈尔数：</strong> 有一些情况下，连续的整数可能都是卡迈尔数，这种情况在数论中被称为 “卡迈尔链”。</li>
<li><strong>卡迈尔数的分布：</strong> 卡迈尔数的分布性质在数论中是一个有趣的研究课题，虽然它们比素数更稀有，但它们的分布情况仍然是一个开放的问题。</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>将</mtext><msup><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="1em"></mspace><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"></mspace><mi>n</mi><mo stretchy="false">)</mo><mtext>中的指数</mtext><mi>n</mi><mo>−</mo><mn>1</mn><mtext>分解为</mtext><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mi>u</mi><mo>×</mo><msup><mn>2</mn><mi>t</mi></msup><mtext>，在每轮测试中对随机出来的</mtext><mi>a</mi><mtext>先求出</mtext><mi>v</mi><mo>=</mo><msup><mi>a</mi><mi>u</mi></msup><mtext> </mtext><mo lspace="0.22em" rspace="0.22em"><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow></mo><mtext> </mtext><mi>n</mi><mtext>，之后对这个值执行最多</mtext><mi>t</mi><mtext>次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则再使用</mtext><mi>F</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi><mtext>素性测试判断。</mtext></mrow><annotation encoding="application/x-tex">将 a^{n-1} \equiv 1 \pmod n 中的指数 n−1 分解为 n−1=u \times 2^t，在每轮测试中对随机出来的 a 先求出 v = a^{u} \bmod n，之后对这个值执行最多 t 次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则再使用 Fermat 素性测试判断。
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord cjk_fallback">将</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord cjk_fallback">中的指数</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord cjk_fallback">分解为</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8436em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，在每轮测试中对随机出来的</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">先求出</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7144em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">u</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.0556em;"></span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">n</span><span class="mord cjk_fallback">，之后对这个值执行最多</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则再使用</span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">t</span><span class="mord cjk_fallback">素性测试判断。</span></span></span></span></span></p>
<p>这种方法是一种改进的素性测试算法，结合了二次探测定理中的指数分解以及费马素性测试的思想。下面是这个算法的基本步骤：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084022187.png" alt="image-20240305084022187"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084041922.png" alt="image-20240305084041922"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084106107.png" alt="image-20240305084106107"></p>
<pre><code>def millerRabin(n):
    if n &lt; 3 or n % 2 == 0:
        return n == 2
    u, t = n - 1, 0
    while u % 2 == 0:
        u = u // 2
        t = t + 1
    # test_time 为测试次数,建议设为不小于 8
    # 的整数以保证正确率,但也不宜过大,否则会影响效率
    for i in range(test_time):
        a = random.randint(2, n - 1)
        v = pow(a, u, n)
        if v == 1:
            continue
        s = 0
        while s &lt; t:
            if v == n - 1:
                break
            v = v * v % n
            s = s + 1
        # 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t
        # 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1
        if s == t:
            return False
    return True

</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084510922.png" alt="image-20240305084510922"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084815004.png" alt="image-20240305084815004"></p>
<pre><code>bool millerRabin(int n) {
  if (n &lt; 3 || n % 2 == 0) return n == 2;
  int u = n - 1, t = 0;
  while (u % 2 == 0) u /= 2, ++t;
  // test_time 为测试次数，建议设为不小于 8
  // 的整数以保证正确率，但也不宜过大，否则会影响效率
  for (int i = 0; i &lt; test_time; ++i) {
    int a = rand() % (n - 2) + 2, v = quickPow(a, u, n);
    if (v == 1) continue;
    int s;
    for (s = 0; s &lt; t; ++s) {
      if (v == n - 1) break;  // 得到平凡平方根 n-1，通过此轮测试
      v = (long long)v * v % n;
    }
    // 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t
    // 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1
    if (s == t) return 0;
  }
  return 1;
}
</code></pre>
<pre><code>def millerRabin(n):
    if n &lt; 3 or n % 2 == 0:
        return n == 2
    u, t = n - 1, 0
    while u % 2 == 0:
        u = u // 2
        t = t + 1
    # test_time 为测试次数,建议设为不小于 8
    # 的整数以保证正确率,但也不宜过大,否则会影响效率
    for i in range(test_time):
        a = random.randint(2, n - 1)
        v = pow(a, u, n)
        if v == 1:
            continue
        s = 0
        while s &lt; t:
            if v == n - 1:
                break
            v = v * v % n
            s = s + 1
        # 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t
        # 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1
        if s == t:
            return False
    return True
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305091117898.png" alt="image-20240305091117898"></p>
<pre><code>import random

def power(x, y, p):
    # 计算 x^y mod p
    res = 1
    x = x % p
    while y &gt; 0:
        if y &amp; 1:
            res = (res * x) % p
        y = y &gt;&gt; 1
        x = (x * x) % p
    return res

def miller_rabin(n, k):
    # 如果 n &lt; 4，直接返回 True 或 False
    if n &lt;= 1:
        return False
    if n &lt;= 3:
        return True

    # 计算 n-1 = d*2^r
    r = 0
    d = n - 1
    while d % 2 == 0:
        r += 1
        d //= 2

    # 进行 k 次检验
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = power(a, d, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = (x * x) % n
            if x == n - 1:
                break
        else:
            return False
    return True

# 示例：对 2^64 范围内的数进行 Miller-Rabin 素性检验
bases = [2, 325, 9375, 28178, 450775, 9780504, 1795265022]
num = 999999999999999989
if miller_rabin(num, 7):
    print(num, "is prime")
else:
    print(num, "is composite")

</code></pre>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

using namespace std;

long long power(long long x, long long y, long long p) {
    // 计算 x^y mod p
    long long res = 1;
    x = x % p;
    while (y &gt; 0) {
        if (y &amp; 1) {
            res = (res * x) % p;
        }
        y = y &gt;&gt; 1;
        x = (x * x) % p;
    }
    return res;
}

bool miller_rabin(long long n, int k) {
    // 如果 n &lt; 4，直接返回 true 或 false
    if (n &lt;= 1) return false;
    if (n &lt;= 3) return true;

    // 计算 n-1 = d*2^r
    int r = 0;
    long long d = n - 1;
    while (d % 2 == 0) {
        r += 1;
        d /= 2;
    }

    // 进行 k 次检验
    for (int i = 0; i &lt; k; ++i) {
        long long a = rand() % (n - 3) + 2;
        long long x = power(a, d, n);
        if (x == 1 || x == n - 1) continue;
        for (int j = 0; j &lt; r - 1; ++j) {
            x = (x * x) % n;
            if (x == n - 1) break;
        }
        if (x != n - 1) return false;
    }
    return true;
}

int main() {
    // 示例：对 2^64 范围内的数进行 Miller-Rabin 素性检验
    srand(time(NULL));
    long long num = 999999999999999989LL;
    if (miller_rabin(num, 7)) {
        cout &lt;&lt; num &lt;&lt; " is prime" &lt;&lt; endl;
    } else {
        cout &lt;&lt; num &lt;&lt; " is composite" &lt;&lt; endl;
    }
    return 0;
}

</code></pre>
<p>如果某个正整数 n 满足如下条件，则称为是 <strong>反素数</strong>：任何小于 n 的正数的约数个数都小于 n 的约数个数</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305092039671.png" alt="image-20240305092039671"></p>
<p>神！调整分析法</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305092614528.png" alt="image-20240305092614528"></p>
<p>对于这种题，我们只要以因子数为 dfs 的返回条件基准，不断更新找到的最小值就可以了</p>
<pre><code>#include &lt;stdio.h&gt;
unsigned long long p[16] = {
    2,  3,  5,  7,  11, 13, 17, 19,
    23, 29, 31, 37, 41, 43, 47, 53};  // 根据数据范围可以确定使用的素数最大为53

unsigned long long ans;
unsigned long long n;

// depth: 当前在枚举第几个素数
// temp: 当前因子数量为 num的时候的数值
// num: 当前因子数
// up：上一个素数的幂，这次应该小于等于这个幂次嘛
void dfs(unsigned long long depth, unsigned long long temp,
         unsigned long long num, unsigned long long up) {
  if (num &gt; n || depth &gt;= 16) return;  // 边界条件
  if (num == n &amp;&amp; ans &gt; temp) {        // 取最小的ans
    ans = temp;
    return;
  }
  for (int i = 1; i &lt;= up; i++) {
    if (temp * p[depth] &gt; ans)
      break;  // 剪枝：如果加一个这个乘数的结果比ans要大，则必不是最佳方案
    dfs(depth + 1, temp = temp * p[depth], num * (i + 1),
        i);  // 取一个该乘数，进行对下一个乘数的搜索
  }
}

int main() {
  scanf("%llu", &amp;n);
  ans = ~(unsigned long long)0;
  dfs(0, 1, 1, 64);
  printf("%llu\n", ans);
  return 0;
}
</code></pre>
<p>dfs 神！</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305093108941.png" alt="image-20240305093108941"></p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;

int p[16] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};
unsigned long long n;
unsigned long long ans,
    ans_num;  // ans 为 n 以内的最大反素数（会持续更新），ans_sum 为
              // ans的因子数。

// depth: 当前在枚举第几个素数
// temp: 当前因子数量为 num的时候的数值
// num: 当前因子数
// up：上一个素数的幂，这次应该小于等于这个幂次嘛
void dfs(int depth, unsigned long long temp, unsigned long long num, int up) {
  if (depth &gt;= 16 || temp &gt; n) return;
  if (num &gt; ans_num) {  // 更新答案
    ans = temp;
    ans_num = num;
  }
  if (num == ans_num &amp;&amp; ans &gt; temp) ans = temp;  // 更新答案
  for (int i = 1; i &lt;= up; i++) {
    if (temp * p[depth] &gt; n)
      break;  // 剪枝：如果加一个这个乘数的结果比ans要大，则必不是最佳方案
    dfs(depth + 1, temp *= p[depth], num * (i + 1),
        i);  // 取一个该乘数，进行对下一个乘数的搜索
  }
  return;
}

int main() {
  while (scanf("%llu", &amp;n) != EOF) {
    ans_num = 0;
    dfs(0, 1, 1, 60);
    printf("%llu\n", ans);
  }
  return 0;
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305093256296.png" alt="image-20240305093256296"></p>
<p>gcd(a,b)=gcd(b,a mod b)</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305093448183.png" alt="image-20240305093448183"></p>
<pre><code>// Version 1
int gcd(int a, int b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}

// Version 2
int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }
</code></pre>
<pre><code>int gcd(int a, int b) {
  while (b != 0) {
    int tmp = a;
    a = b;
    b = tmp % b;
  }
  return a;
}
</code></pre>
<pre><code>def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)
</code></pre>
<pre><code>def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
</code></pre>
<p>另外，对于 C<ins>14，我们可以使用自带的  <code>__gcd(a,b)</code>  函数来求最大公约数。而对于 C</ins> 17，我们可以使用 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/numeric">``</a> 头中的 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/numeric/gcd"> <code>std::gcd</code> </a> 与 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/numeric/lcm"> <code>std::lcm</code> </a> 来求最大公约数和最小公倍数。</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305095100433.png" alt="image-20240305095100433"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305095146169.png" alt="image-20240305095146169"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305095941238.png" alt="image-20240305095941238"></p>
<pre><code>Big gcd(Big a, Big b) {
  // 记录a和b的公因数2出现次数
  int atimes = 0, btimes = 0;
  while (a % 2 == 0) {
    a &gt;&gt;= 1;
    atimes++;
  }
  while (b % 2 == 0) {
    b &gt;&gt;= 1;
    btimes++;
  }
  for (;;) {
    // a和b公因数中的2已经计算过了，后面不可能出现a,b均为偶数的情况
    while (a % 2 == 0) {
      a &gt;&gt;= 1;
    }
    while (b % 2 == 0) {
      b &gt;&gt;= 1;
    }
    if (a == b) break;
    // 确保 a&gt;=b
    if (a &lt; b) swap(a, b);
    a -= b;
  }
  return a &lt;&lt; min(atimes, btimes);
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305100854375.png" alt="image-20240305100854375"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305100917948.png" alt="image-20240305100917948"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305101025113.png" alt="image-20240305101025113"></p>
<pre><code>int gcd(int a, int b, int&amp; x, int&amp; y) {
  x = 1, y = 0;
  int x1 = 0, y1 = 1, a1 = a, b1 = b;
  while (b1) {
    int q = a1 / b1;
    tie(x, x1) = make_tuple(x1, x - q * x1);
    tie(y, y1) = make_tuple(y1, y - q * y1);
    tie(a1, b1) = make_tuple(b1, a1 - q * b1);
  }
  return a1;
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102040888.png" alt="image-20240305102040888"></p>
<p>线性代数 yyds</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102254449.png" alt="image-20240305102254449"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102303903.png" alt="image-20240305102303903"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102312659.png" alt="image-20240305102312659"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102631758.png" alt="image-20240305102631758"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102721727.png" alt="image-20240305102721727"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102823965.png" alt="image-20240305102823965"></p>
<pre><code>long long H(int n) {
  long long res = 0;  // 储存结果
  int l = 1, r;       // 块左端点与右端点
  while (l &lt;= n) {
    r = n / (n / l);  // 计算当前块的右端点
    res += (r - l + 1) * 1LL *
           (n / l);  // 累加这一块的贡献到结果中。乘上 1LL 防止溢出
    l = r + 1;  // 左端点移到下一块
  }
  return res;
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305103222715.png" alt="image-20240305103222715"></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2261">CQOI2007 余数求和</a>（需要一点转化和特判）</li>
<li><a target="_blank" rel="noopener" href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=27&amp;page=show_problem&amp;problem=2521">UVa11526 H(n)</a>（几乎可以当做模板题）</li>
<li><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3455">POI2007 ZAP-Queries</a>（数论分块一般配合 <a target="_blank" rel="noopener" href="https://oiwiki.com/math/number-theory/mobius/">莫比乌斯反演</a> 用以进一步降低复杂度；本题需要用到 <img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305105002108.png" alt="image-20240305105002108"></li>
</ol>
<p>欧拉函数 表示的是小于等于 n 和互质的数的个数</p>
<p>当 n 是质数的时候，欧拉函数等于 n-1</p>
<p>性质</p>
<ul>
<li>欧拉函数是积性函数</li>
<li>gcd (a,b)=1, 则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mi>a</mi><mo>∗</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(a*b)=\phi(a)*\phi(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></li>
<li>特别的，当 n 是奇数的时候，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\phi(2n)=\phi(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ϕ</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre><code>#include &lt;cmath&gt;

int euler_phi(int n) {
  int ans = n;
  for (int i = 2; i * i &lt;= n; i++)
    if (n % i == 0) {
      ans = ans / i * (i - 1);
      while (n % i == 0) n /= i;
    }
  if (n &gt; 1) ans = ans / n * (n - 1);
  return ans;
}
</code></pre>
<p>这种算法的时间复杂度是 O (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.2397em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8003em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal">n</span></span></span><span style="top:-2.7603em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2397em;"><span></span></span></span></span></span></span></span></span>)</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305110411881.png" alt="image-20240305110411881"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305110620807.png" alt="image-20240305110620807"></p>
<pre><code>ll Pollard_Rho(ll N) {
  ll c = rand() % (N - 1) + 1;
  ll t = f(0, c, N);
  ll r = f(f(0, c, N), c, N);
  while (t != r) {
    ll d = gcd(abs(t - r), N);
    if (d &gt; 1) return d;
    t = f(t, c, N);
    r = f(f(r, c, N), c, N);
  }
  return N;
}
</code></pre>
<pre><code>ll Pollard_Rho(ll N) {
  ll c = rand() % (N - 1) + 1;
  ll t = f(0, c, N);
  ll r = f(f(0, c, N), c, N);
  while (t != r) {
    ll d = gcd(abs(t - r), N);
    if (d &gt; 1) return d;
    t = f(t, c, N);
    r = f(f(r, c, N), c, N);
  }
  return N;
}

</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305111254401.png" alt="image-20240305111254401"></p>
<p>倍增优化的代码实现</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305111849993.png" alt="image-20240305111849993"></p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long ll;

int t;
long long max_factor, n;

long long gcd(long long a, long long b) {
  if (b == 0) return a;
  return gcd(b, a % b);
}

long long quick_pow(long long x, long long p, long long mod) {  // 快速幂
  long long ans = 1;
  while (p) {
    if (p &amp; 1) ans = (__int128)ans * x % mod;
    x = (__int128)x * x % mod;
    p &gt;&gt;= 1;
  }
  return ans;
}

bool Miller_Rabin(long long p) {  // 判断素数
  if (p &lt; 2) return 0;
  if (p == 2) return 1;
  if (p == 3) return 1;
  long long d = p - 1, r = 0;
  while (!(d &amp; 1)) ++r, d &gt;&gt;= 1;  // 将d处理为奇数
  for (long long k = 0; k &lt; 10; ++k) {
    long long a = rand() % (p - 2) + 2;
    long long x = quick_pow(a, d, p);
    if (x == 1 || x == p - 1) continue;
    for (int i = 0; i &lt; r - 1; ++i) {
      x = (__int128)x * x % p;
      if (x == p - 1) break;
    }
    if (x != p - 1) return 0;
  }
  return 1;
}

long long Pollard_Rho(long long x) {
  long long s = 0, t = 0;
  long long c = (long long)rand() % (x - 1) + 1;
  int step = 0, goal = 1;
  long long val = 1;
  for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
    for (step = 1; step &lt;= goal; ++step) {
      t = ((__int128)t * t + c) % x;
      val = (__int128)val * abs(t - s) % x;
      if ((step % 127) == 0) {
        long long d = gcd(val, x);
        if (d &gt; 1) return d;
      }
    }
    long long d = gcd(val, x);
    if (d &gt; 1) return d;
  }
}

void fac(long long x) {
  if (x &lt;= max_factor || x &lt; 2) return;
  if (Miller_Rabin(x)) {              // 如果x为质数
    max_factor = max(max_factor, x);  // 更新答案
    return;
  }
  long long p = x;
  while (p &gt;= x) p = Pollard_Rho(x);  // 使用该算法
  while ((x % p) == 0) x /= p;
  fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
  scanf("%d", &amp;t);
  while (t--) {
    srand((unsigned)time(NULL));
    max_factor = 0;
    scanf("%lld", &amp;n);
    fac(n);
    if (max_factor == n)  // 最大的质因数即自己
      printf("Prime\n");
    else
      printf("%lld\n", max_factor);
  }
  return 0;
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121231841.png" alt="image-20240305121231841"></p>
<pre><code>vector&lt;int&gt; prime;
bool is_prime[N];

void Eratosthenes(int n) {
  is_prime[0] = is_prime[1] = false;
  for (int i = 2; i &lt;= n; ++i) is_prime[i] = true;
  for (int i = 2; i &lt;= n; ++i) {
    if (is_prime[i]) {
      prime.push_back(i);
      if ((long long)i * i &gt; n) continue;
      for (int j = i * i; j &lt;= n; j += i)
        // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i
        // 的倍数开始，提高了运行速度
        is_prime[j] = false;  // 是 i 的倍数的均不是素数
    }
  }
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121344310.png" alt="image-20240305121344310"></p>
<p>筛至平方根提高效率</p>
<pre><code>vector&lt;int&gt; prime;
bool is_prime[N];

void Eratosthenes(int n) {
  is_prime[0] = is_prime[1] = false;
  for (int i = 2; i &lt;= n; ++i) is_prime[i] = true;
  // i * i &lt;= n 说明 i &lt;= sqrt(n)
  for (int i = 2; i * i &lt;= n; ++i) {
    if (is_prime[i])
      for (int j = i * i; j &lt;= n; j += i) is_prime[j] = false;
  }
  for (int i = 2; i &lt;= n; ++i)
    if (is_prime[i]) prime.push_back(i);
}






prime = []
is_prime = [False] * N

def Eratosthenes(n):
    is_prime[0] = is_prime[1] = False
    for i in range(2, n + 1):
        is_prime[i] = True
    # 让 i 循环到 &lt;= sqrt(n)
    for i in range(2, isqrt(n) + 1): # `isqrt` 是 Python 3.8 新增的函数
        if is_prime[i]:
            for j in range(i * i, n + 1, i):
                is_prime[j] = False
    for i in range(2, n + 1):
        if is_prime[i]:
            prime.append(i)


</code></pre>
<p>这种优化不会影响渐进时间复杂度，实际上重复以上证明，我们将得到 <img loading="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="n n n qrt n + o(n)">，根据对数的性质，它们的渐进相同，但操作次数会明显减少。</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121447195.png" alt="image-20240305121447195"></p>
<pre><code>int count_primes(int n) {
  const int S = 10000;
  vector&lt;int&gt; primes;
  int nsqrt = sqrt(n);
  vector&lt;char&gt; is_prime(nsqrt + 1, true);
  for (int i = 2; i &lt;= nsqrt; i++) {
    if (is_prime[i]) {
      primes.push_back(i);
      for (int j = i * i; j &lt;= nsqrt; j += i) is_prime[j] = false;
    }
  }
  int result = 0;
  vector&lt;char&gt; block(S);
  for (int k = 0; k * S &lt;= n; k++) {
    fill(block.begin(), block.end(), true);
    int start = k * S;
    for (int p : primes) {
      int start_idx = (start + p - 1) / p;
      int j = max(start_idx, p) * p - start;
      for (; j &lt; S; j += p) block[j] = false;
    }
    if (k == 0) block[0] = block[1] = false;
    for (int i = 0; i &lt; S &amp;&amp; start + i &lt;= n; i++) {
      if (block[i]) result++;
    }
  }
  return result;
}
</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121508991.png" alt="image-20240305121508991"></p>
<p>卧槽不断优化牛逼</p>
<pre><code>vector&lt;int&gt; pri;
bool not_prime[N];

void pre(int n) {
  for (int i = 2; i &lt;= n; ++i) {
    if (!not_prime[i]) {
      pri.push_back(i);
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        // i % pri_j == 0
        // 换言之，i 之前被 pri_j 筛过了
        // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被
        // pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break
        // 掉就好了
        break;
      }
    }
  }
}


pri = []
not_prime = [False] * N

def pre(n):
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                """
                i % pri_j == 0
                换言之，i 之前被 pri_j 筛过了
                由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被
                pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break
                掉就好了
                """
                break
                
                
                
                
筛法求欧拉函数
vector&lt;int&gt; pri;
bool not_prime[N];
int phi[N];

void pre(int n) {
  phi[1] = 1;
  for (int i = 2; i &lt;= n; i++) {
    if (!not_prime[i]) {
      pri.push_back(i);
      phi[i] = i - 1;
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        phi[i * pri_j] = phi[i] * pri_j;
        break;
      }
      phi[i * pri_j] = phi[i] * phi[pri_j];
    }
  }
}

pri = []
not_prime = [False] * N
phi = [0] * N

def pre(n):
    phi[1] = 1
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
            phi[i] = i - 1
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                phi[i * pri_j] = phi[i] * pri_j
                break
            phi[i * pri_j] = phi[i] * phi[pri_j]
</code></pre>
<p>筛法求莫比乌斯函数是一种用于计算莫比乌斯函数值的有效方法，它可以在线性时间内计算出一定范围内所有数的莫比乌斯函数值。这种方法通常被称为线性筛法。</p>
<p>线性筛法的基本思想是利用数论中的一些性质，在遍历过程中逐步计算每个数的莫比乌斯函数值，同时将合数标记出来，以避免重复计算。</p>
<p>以下是线性筛法求莫比乌斯函数的基本步骤：</p>
<ol>
<li>初始化一个数组  <code>mu[]</code> ，用于存储每个数的莫比乌斯函数值，初始值为 1。</li>
<li>遍历从 2 到 n 的每个数 i，对于每个素数，将其莫比乌斯函数值设置为 -1（因为素数的莫比乌斯函数值为 -1），同时将所有大于 1 的 i 的倍数的莫比乌斯函数值设置为 0。</li>
<li>对于每个大于 1 的数 i，如果 i 可以被某个素数 p 整除，则将 i 的莫比乌斯函数值设置为 -mu [i/p]，否则设置为 0。</li>
<li>最后得到的数组  <code>mu[]</code>  中存储了从 1 到 n 的每个数的莫比乌斯函数值。</li>
</ol>
<p>下面是用 C++ 实现线性筛法求莫比乌斯函数的示例代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;int&gt; mobius(int n) {
    vector&lt;int&gt; mu(n + 1, 1);
    vector&lt;int&gt; prime;
    vector&lt;bool&gt; is_prime(n + 1, true);
    mu[1] = 1;
    for (int i = 2; i &lt;= n; ++i) {
        if (is_prime[i]) {
            prime.push_back(i);
            mu[i] = -1;
        }
        for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; ++j) {
            is_prime[i * prime[j]] = false;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                break;
            } else {
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    return mu;
}

int main() {
    int n = 10;
    vector&lt;int&gt; mu = mobius(n);
    for (int i = 1; i &lt;= n; ++i) {
        cout &lt;&lt; "mu[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; mu[i] &lt;&lt; endl;
    }
    return 0;
}

</code></pre>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121752199.png" alt="image-20240305121752199"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121804238.png" alt="image-20240305121804238"></p>
<pre><code>vector&lt;int&gt; pri;
bool not_prime[N];
int mu[N];

void pre(int n) {
  mu[1] = 1;
  for (int i = 2; i &lt;= n; ++i) {
    if (!not_prime[i]) {
      mu[i] = -1;
      pri.push_back(i);
    }
    for (int pri_j : pri) {
      if (i * pri_j &gt; n) break;
      not_prime[i * pri_j] = true;
      if (i % pri_j == 0) {
        mu[i * pri_j] = 0;
        break;
      }
      mu[i * pri_j] = -mu[i];
    }
  }
}
</code></pre>
<pre><code>pri = []
not_prime = [False] * N
mu = [0] * N

def pre(n):
    mu[1] = 1
    for i in range(2, n + 1):
        if not not_prime[i]:
            pri.append(i)
            mu[i] = -1
        for pri_j in pri:
            if i * pri_j &gt; n:
                break
            not_prime[i * pri_j] = True
            if i % pri_j == 0:
                mu[i * pri_j] = 0
                break
            mu[i * pri_j] = -mu[i]
</code></pre>
<p><a target="_blank" rel="noopener" href="https://oiwiki.com/lang/csl/bitset/#%E4%B8%8E%E5%9F%83%E6%B0%8F%E7%AD%9B%E7%BB%93%E5%90%88">bitset: 与埃氏筛结合</a></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305202129807.png" alt="image-20240305202129807"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305204945833.png" alt="image-20240305204945833"></p>
<p>约数个数定理，其实就是乘法原理<img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305205022866.png" alt="image-20240305205022866"></p>
<ul>
<li>当 i 为质数时，最小质因子出现的次数为 1，约数个数为 2，q=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mfrac><mi>i</mi><mi>p</mi></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\frac{i}{p}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3368em;vertical-align:-0.4811em;"></span><span class="mopen">[</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8557em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span>,p 为 i 的最小质因子</li>
<li>当 p 为 q 的质因子时，就是 i 除以 p 取整的结果还能被 p 除，也就是说去掉最小值因子的幂次大于等于 2. 在这个时候 i 的最小质因子出现的次数 + 1，<img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305205557612.png" alt="image-20240305205557612">，因为<img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305205605639.png" alt="image-20240305205605639"></li>
</ul>
<p>q 的话就是每个指数 + 1 全部乘在一起，i 的话也是每个指数 + 1 全部乘在一起，di/dq 的话其实就是最小质因子的次数不同，而他们的最小质因子是同一个。对于 i 最小值因子的质数 numi，所以要乘以 numi+1，对于 q 最小值因子的质数是 i-1，所以乘以 numi，所以比值是 numi+1/numi、</p>
<ul>
<li>当 p、q 互质时，numi 是等于 1 的。i=p<em>q, 比如说 7</em> * 24，di 等于 dq 乘以（numi+1），就是缺的那一个完全独立的乘上去就行</li>
<li><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305221003952.png" alt="image-20240305221003952"></li>
</ul>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305221155319.png" alt="image-20240305221155319"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305221552265.png" alt="image-20240305221552265"></p>
<p>类欧几里得算法</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305222951587.png" alt="image-20240305222951587"></p>
<p>这是一个递归的式子。并且你发现 <img loading="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="a,c"> 分子分母换了位置，又可以重复上述过程。先取模，再递归。这就是一个辗转相除的过程，这也是类欧几里德算法的得名。</p>
<p>容易发现时间复杂度为 O (logn)</p>
<p>费马小定理： 若 p 为素数，gcd (a,p)=1, 则 $a^{p-1}\equiv1 mod, p $,</p>
<p>对于任一整数  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>p</mi></msup><mo>≡</mo><mi>a</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>d</mi><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">a^p\equiv a \,mod \,p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">p</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305223806736.png" alt="image-20240305223806736"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305224010396.png" alt="image-20240305224010396"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305224531067.png" alt="image-20240305224531067"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305224552920.png" alt="image-20240305224552920"></p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305224614994.png" alt="image-20240305224614994"></p>
<p>乘法逆元在乘法中对 b 模的同余结果为 1</p>
<pre><code>void exgcd(int a, int b, int&amp; x, int&amp; y) {
  if (b == 0) {
    x = 1, y = 0;
    return;
  }
  exgcd(b, a % b, y, x);
  y -= a / b * x;
}
</code></pre>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">Edited on</span><time title="Modified: 2024-03-05 22:47:09" itemprop="dateModified" datetime="2024-03-05T22:47:09+08:00">2024-03-05</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>Donate</button><p>Give me a cup of [coffee]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.webp" alt="lystics WeChat Pay"><p>WeChat Pay</p></div><div><img loading="lazy" data-src="/assets/alipay.webp" alt="lystics Alipay"><p>Alipay</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Post author: </strong>lystics<i class="ic i-at"><em>@</em></i>Lystics</li><li class="link"><strong>Post link: </strong><a href="https://lysistic.github.io/2024/03/04/number-theory/" title="number_theory">https://lysistic.github.io/2024/03/04/number-theory/</a></li><li class="license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> unless stating additionally.</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/03/04/java/" rel="prev" itemprop="url" data-background-image="https://lysistic.github.io/image/img/img(85).webp" title="java"><span class="type">Previous Post</span><h3>java</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="Contents"></div><div class="related panel pjax" data-title="Related"></div><div class="overview panel" data-title="Overview"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="lystics" src="/assets/avatar.webp"><p class="name" itemprop="name">lystics</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">6</span><span class="name">posts</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/lysistic" class="item github" title="https://github.com/lysistic"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>Home</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/03/04/java/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>Random Posts</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/03/hello-world/">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/03/cpp-O-o/">cpp_O.o</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/04/java/">java</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/12/my-first-article/">my first article</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/04/number-theory/">number_theory</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/03/git-learn/">git-learn</a></span></li></ul></div><div class="rpost pjax"><h2>Recent Comments</h2></div></div><div class="status"><div class="copyright">© 2022 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">lystics @ Hust_CSE_undergraduate</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="Symbols count total">66k words</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="Reading time total">1:01</span></div><div class="powered-by">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> &amp; Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2024/03/04/number-theory/`,
        favicon: {
        show: `(●´3｀●) Here we go again.`,
        hide: `(´Д｀) It's a disaster!`
    },
    search: {
        placeholder: "Search for Posts",
        empty: "We didn't find any results for the search: ${query}",
        stats: "${hits} results found in ${time} ms"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">Article Timeliness Alert</span><br>This is an article published {{publish}} days ago and last updated {{updated}} days ago. Some information may have changed, so please be careful to screen it.</p></div>`,
    quiz: {
        choice: `Multiple Choice`,
        multiple: `Multiple Answer`,
        true_false: `True/False`,
        essay: `Questions`,
        gap_fill: `Gap Filling`,
        mistake: `Wrong Answer`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.2.4/pace.min.js" async=""></script><script src="/js/siteInit.js?v=0.4.2" type="module" fetchpriority="high" defer=""></script></body></html>