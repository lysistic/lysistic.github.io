<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"><meta name="renderer" content="webkit"><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"><link rel="alternate" href="/rss.xml" title="Lystics" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="Lystics" type="application/atom+xml"><link rel="alternate" type="application/json" title="Lystics" href="https://lysistic.github.io/feed.json"><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"><link rel="preconnect" href="https://at.alicdn.com"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&amp;display=swap&amp;subset=latin,latin-ext" media="none" onload="this.media='all'"><link rel="stylesheet" href="/css/app.css?v=0.4.2"><link rel="modulepreload" href="/js/chunk-AHWQPRSO.js"><link rel="modulepreload" href="/js/chunk-D5E3HCIM.js"><link rel="modulepreload" href="/js/chunk-QAWHJ5B3.js"><link rel="modulepreload" href="/js/index.esm-KMEAF737.js"><link rel="modulepreload" href="/js/post-VSW2ZODR.js"><link rel="modulepreload" href="/js/quicklink-L7SCP7EH.js"><link rel="modulepreload" href="/js/siteInit.js"><link rel="preload" href="https://lysistic.github.io/image/img/img(46).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(80).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(30).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(85).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(51).webp" as="image" fetchpriority="high"><link rel="preload" href="https://lysistic.github.io/image/img/img(13).webp" as="image" fetchpriority="high"><link rel="canonical" href="https://lysistic.github.io/2024/03/03/cpp-O-o/"><title>cpp_O.o</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope="" itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope="" itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">cpp_O.o</h1><div class="meta"><span class="item" title="作成日：2024-03-03 13:05:40"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">投稿日</span><time itemprop="dateCreated datePublished" datetime="2024-03-03T13:05:40+08:00">2024-03-03</time></span><span class="item" title="単語数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">単語数</span><span>23k</span><span class="text">単語</span></span><span class="item" title="読書の時間"><span class="icon"><i class="ic i-clock"></i></span><span class="text">読書の時間</span><span>21 分</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="ナビゲーションバーの切り替え"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Hust_CSE_undergraduate</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(46).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(80).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(30).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(85).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(51).webp&quot;);"></li><li class="item" style="background-image: url(&quot;https://lysistic.github.io/image/img/img(13).webp&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemlistelement="" itemscope="" itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">ホーム</a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh"><link itemprop="mainEntityOfPage" href="https://lysistic.github.io/2024/03/03/cpp-O-o/"><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"><meta itemprop="name" content="lystics"><meta itemprop="description" content=", "></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="Lystics"></span><div class="body md" itemprop="articleBody"><ul>
<li>istream // 输入流类型，提供输入操作</li>
<li>ifstream // 由 istream 派生而来，提供文件读入功能</li>
<li>ostream // 输出流类型，提供输出操作</li>
<li>ofstream // 由 ostream 派生而来，提供文件写功能</li>
<li><code>&gt;&gt; 用于从istream对象读入</code></li>
<li><code>&lt;&lt; 用于把输出写道ostream</code></li>
</ul>
<p>iostream 定义读写控制窗口类型</p>
<p>fstream 定义读写已命名文件类型</p>
<p>sstream 所定义的类型读写存储在内存中的 string 对象</p>
<h1 id="智能指针"><a class="anchor" href="#智能指针">#</a> 智能指针</h1>
<p>智能指针就是帮我们 C++ 程序员管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而<strong>避免内存泄漏</strong>！</p>
<p>内存泄漏的例子</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
using namespace std;
// 动态分配内存，没有释放就return
void memoryLeak1() {
	string *str = new string("动态分配内存！");
	return;
}
// 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了
int memoryLeak2() {
	string *str = new string("内存泄露！");
	// ...此处省略一万行代码
	// 发生某些异常，需要结束函数
	if (1) {
		return -1;
	}
	/
	// 另外，使用try、catch结束函数，也会造成内存泄漏！
	/

	delete str;	// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放
	return 1;
}


int main(void) {

	memoryLeak1();

	memoryLeak2();

	return 0;
} 

</code></pre>
<p>使用指针并申请空间，用完没有释放就会造成内存泄漏。</p>
<p>一个可行的方案：</p>
<p>动态分配的内存都交由有生命周期的对象来处理，在对象过期时，让他的析构函数删除指向的内存。</p>
<ol>
<li>C++98 提供了 auto_ptr 模板的解决方案</li>
<li>C++11 增加 unique_ptr、shared_ptr 和 weak_ptr</li>
</ol>
<h2 id="auto_ptr"><a class="anchor" href="#auto_ptr">#</a> auto_ptr</h2>
<p>auto_ptr 是 c++ 98 定义的智能指针模板，其定义了管理指针的对象，可以将 new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用 delete 来释放内存</p>
<p>用法:<br>
 头文件: #include &lt;memory&gt;<br>
 用 法: auto_ptr &lt;类型&gt; 变量名 (new 类型)</p>
<p>例 如:<br>
auto_ptr&lt;string&gt; str (new string (“我要成为大牛～变得很牛逼！”));<br>
auto_ptr&lt;vector&lt; int &gt;&gt; av(new vector&lt; int &gt;());<br>
auto_ptr&lt; int &gt; array(new int[10]);</p>
<pre><code class="language-c++">#include&lt;mem.h&gt;
#include&lt;io.h&gt;
#include&lt;memory&gt;
#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
using namespace std;
class Test {
public:
	Test() { cout &lt;&lt; "gouzao" &lt;&lt; endl; }
	~Test() { cout &lt;&lt; "xigou..." &lt;&lt; endl; }

	int getDebug() { return this-&gt;debug; }

private:
	int debug = 20;
};

using namespace std;
// 定义智能指针
int main(void) {

	//Test *test = new Test;
	auto_ptr&lt;Test&gt; test(new Test);

	cout &lt;&lt; "test-&gt;debug：" &lt;&lt; test-&gt;getDebug() &lt;&lt; endl;
	cout &lt;&lt; "(*test).debug：" &lt;&lt; (*test).getDebug() &lt;&lt; endl;

	return 0;
} 

</code></pre>
<p>在程序退出时调用析构函数释放内存</p>
<p>智能指针常用的三个函数</p>
<p><strong>get</strong> () 获取智能指针托管的指针地址</p>
<p><strong>release</strong> () 取消智能指针对动态内存的托管<strong> reset</strong> () 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</p>
<p><code>auto_ptr</code>  是 C++11 之前的标准库中的智能指针，它具有独占性质，即不能被多个指针共享。因此，将  <code>auto_ptr</code>  变量定义为全局变量或指针可能会导致一些问题：</p>
<ol>
<li><strong>所有权的问题</strong>： <code>auto_ptr</code>  采用了独占所有权的策略，当一个  <code>auto_ptr</code>  对象被赋值给另一个  <code>auto_ptr</code>  对象时，原来的  <code>auto_ptr</code>  对象就失去了对资源的控制权。如果将  <code>auto_ptr</code>  定义为全局变量，那么在程序的不同部分可能会意外地修改或释放全局变量指向的资源，导致不可预测的行为。</li>
<li><strong>析构顺序问题</strong>：全局变量的析构顺序是未定义的，而  <code>auto_ptr</code>  的析构函数会释放其所管理的资源。如果  <code>auto_ptr</code>  的析构函数被调用时，其他全局变量还在使用这个资源，可能会导致未定义的行为或内存错误。</li>
<li><strong>线程安全问题</strong>：全局变量的访问可能不是线程安全的，如果多个线程同时访问全局变量，可能会发生竞态条件。而  <code>auto_ptr</code>  的操作并不是线程安全的，因此在多线程环境下，使用全局的  <code>auto_ptr</code>  可能会导致竞态条件，从而导致资源泄漏或内存错误。</li>
</ol>
<p>由于上述问题，尽可能不要将  <code>auto_ptr</code>  变量定义为全局变量或指针。相反，应该将  <code>auto_ptr</code>  定义为局部变量，以便在离开作用域时自动释放资源，并避免共享资源的所有权。在 C++11 之后，推荐使用更安全的智能指针，如  <code>unique_ptr</code>  或  <code>shared_ptr</code> 。</p>
<p>除非自己知道后果，不要把 auto_ptr 智能指针赋值给同类型的另外一个 智能指针</p>
<p>正是的。 <code>auto_ptr</code>  是一种具有独占所有权的智能指针，它的特性决定了它只能被移动，而不能被复制。当你将一个  <code>auto_ptr</code>  赋值给另一个  <code>auto_ptr</code>  时，所有权会从一个指针转移到另一个指针，原始指针会失去所有权。</p>
<p>这种转移所有权的行为可能导致一些潜在的问题，尤其是在程序的不同部分使用了同一个资源时。具体来说，可能会出现以下问题：</p>
<ol>
<li><strong>悬空指针（Dangling Pointer）</strong>：如果不小心将一个  <code>auto_ptr</code>  赋值给另一个  <code>auto_ptr</code> ，并且原始指针在后续的使用中还会被访问，那么就可能出现悬空指针的问题，即指向已经释放的内存的指针。</li>
<li><strong>资源泄漏（Resource Leak）</strong>：如果不正确地管理  <code>auto_ptr</code> ，可能会导致资源泄漏。例如，在将  <code>auto_ptr</code>  赋值给另一个  <code>auto_ptr</code>  之后，原始指针没有被释放，导致资源无法释放。</li>
<li><strong>不确定的行为（Undefined Behavior）</strong>：由于  <code>auto_ptr</code>  的独占性质，可能会导致在不同的地方意外地释放资源或者使用已经释放的资源，从而导致不确定的行为。</li>
</ol>
<p>因此，除非你清楚地了解后果并能够确保安全使用，否则不要将  <code>auto_ptr</code>  智能指针赋值给同类型的另一个智能指针。在现代 C++ 中，推荐使用更安全的智能指针，如  <code>unique_ptr</code>  或  <code>shared_ptr</code> ，它们提供了更严格的所有权控制，并且避免了  <code>auto_ptr</code>  可能带来的问题</p>
<p>C<ins>11 后 auto_ptr 已经被 “抛弃”，已使用 unique_ptr 替代！C</ins>11 后不建议使用 auto_ptr</p>
<h3 id="auto_ptr-被c11抛弃的主要原因"><a class="anchor" href="#auto_ptr-被c11抛弃的主要原因">#</a> <strong>auto_ptr 被 C++11 抛弃的主要原因</strong></h3>
<p>复制或者赋值都会改变资源的所有权</p>
<p>在 STL 容器中使用 auto_ptr 存在着重大风险，因为容器内的元素必须支持可复制和可赋值</p>
<p>在 C++ 中，左值（lvalue）和右值（rvalue）是用于描述表达式的术语。</p>
<ul>
<li>
<p><strong>左值（lvalue）</strong>：左值是指可以被赋值的表达式，通常是可以取地址的表达式。具体来说，左值是一个具有标识符（即有名称）并且可以通过地址获取其值的表达式。例如，变量、数组元素、函数返回的引用等都是左值。例如：</p>
<pre><code>cppCopy codeint x = 5; // x是左值
int arr[5]; // arr是左值
int&amp; ref = x; // ref是左值
</code></pre>
</li>
<li>
<p><strong>右值（rvalue）</strong>：右值是指不能被赋值的表达式，通常是临时的、一次性的值。右值没有名称，通常在表达式求值后就消失了。例如，常量、临时对象、函数返回的非引用值等都是右值。例如：</p>
<pre><code>cppCopy code5 + 3; // 5 + 3是右值
int* ptr = new int(10); // new int(10)返回的是右值
</code></pre>
</li>
</ul>
<p>在 C++11 中引入了右值引用（rvalue references），它允许我们更方便地处理右值，并且可以实现移动语义，提高程序的性能。右值引用使用  <code>&amp;&amp;</code>  来声明，例如：</p>
<pre><code>cppCopy code
int&amp;&amp; rv = 5; // rv是右值引用
</code></pre>
<p>在 C++ 中，直接将右值绑定到左值引用是不允许的。因为左值引用是用于引用左值的，而右值是临时的、一次性的值，不具备地址，无法通过引用来访问。试图将右值直接绑定到左值引用会导致编译错误。</p>
<p>例如，以下代码会导致编译错误：</p>
<pre><code>cppCopy code
int&amp; rv = 5; // 错误：无法将右值绑定到左值引用
</code></pre>
<p>正确的做法是使用右值引用来绑定右值：</p>
<pre><code>cppCopy code
int&amp;&amp; rv = 5; // 正确：使用右值引用绑定右值
</code></pre>
<p>或者，你可以使用  <code>const</code>  修饰左值引用，这样就可以将右值绑定到  <code>const</code>  左值引用：</p>
<pre><code>cppCopy code
const int&amp; rv = 5; // 正确：使用const左值引用绑定右值
</code></pre>
<p>这样做是合法的，因为  <code>const</code>  左值引用可以延长右值的生命周期，使其与引用的生命周期相匹配。</p>
<p>不支持对象数组的内存管理</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

using namespace std;

class Test {
public:
	Test() { cout &lt;&lt; "Test的构造函数..." &lt;&lt; endl; }
	~Test() { cout &lt;&lt; "Test的析构函数..." &lt;&lt; endl; }

	int getDebug() { return this-&gt;debug; }

private:
	int debug = 20;
};

// 不要定义为全局变量，没有意义
//auto_ptr&lt;Test&gt; test(new Test);

void memoryLeak1() {
	//Test *test = new Test;

	// 定义智能指针
	auto_ptr&lt;Test&gt; test(new Test);
	
	cout &lt;&lt; "test-&gt;debug：" &lt;&lt; test-&gt;getDebug() &lt;&lt; endl;
	cout &lt;&lt; "(*test).debug：" &lt;&lt; (*test).getDebug() &lt;&lt; endl;


	// get方法
	Test *tmp = test.get();		// 获取指针返回
	cout &lt;&lt; "tmp-&gt;debug：" &lt;&lt; tmp-&gt;getDebug() &lt;&lt; endl;


	// release方法
	Test *tmp2 = test.release();	// 取消智能指针对动态内存的托管
	delete tmp2;	// 之前分配的内存需要自己手动释放


	// reset方法：重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉
	test.reset();			// 释放掉智能指针托管的指针内存，并将其置NULL
	test.reset(new Test());	// 释放掉智能指针托管的指针内存，并将参数指针取代之


	// 忠告：不要将智能指针定义为指针
	//auto_ptr&lt;Test&gt; *tp = new auto_ptr&lt;Test&gt;(new Test);

	// 忠告：不要定义指向智能指针对象的指针变量
	//auto_ptr&lt;Test&gt; t1(new Test);
	//auto_ptr&lt;Test&gt; t2(new Test);
	//t1 = t2;

	return;
}

int memoryLeak2() {
	//Test *test = new Test();

	// 定义智能指针
	auto_ptr&lt;Test&gt; test(new Test);

	// ...此处省略一万行代码

	// 发生某些异常，需要结束函数
	if (1) {
		return -1;
	}

	//delete test;
	return 1;
}


int main1(void) {

	//memoryLeak1();

	//memoryLeak2();

	//Test *test = new Test;
	//auto_ptr&lt;Test&gt; test(new Test);

	//cout &lt;&lt; "test-&gt;debug：" &lt;&lt; test-&gt;getDebug() &lt;&lt; endl;
	//cout &lt;&lt; "(*test).debug：" &lt;&lt; (*test).getDebug() &lt;&lt; endl;


	 auto_ptr 被C++11抛弃的主要原因
	//auto_ptr&lt;string&gt; p1(new string("I'm Li Ming!"));
	//auto_ptr&lt;string&gt; p2(new string("I'm age 22."));
	//
	//cout &lt;&lt; "p1：" &lt;&lt; p1.get() &lt;&lt; endl;
	//cout &lt;&lt; "p2：" &lt;&lt; p2.get() &lt;&lt; endl;

	//p1 = p2;
	//cout &lt;&lt; "p1 = p2 赋值后：" &lt;&lt; endl;
	//cout &lt;&lt; "p1：" &lt;&lt; p1.get() &lt;&lt; endl;
	//cout &lt;&lt; "p2：" &lt;&lt; p2.get() &lt;&lt; endl;



	// 弊端2.在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制
	vector&lt;auto_ptr&lt;string&gt;&gt; vec;
	auto_ptr&lt;string&gt; p3(new string("I'm P3"));
	auto_ptr&lt;string&gt; p4(new string("I'm P4"));

	vec.push_back(std::move(p3));
	vec.push_back(std::move(p4));

	cout &lt;&lt; "vec.at(0)：" &lt;&lt;  *vec.at(0) &lt;&lt; endl;
	cout &lt;&lt; "vec[1]：" &lt;&lt;  *vec[1] &lt;&lt; endl;


	// 风险来了：
	vec[0] = vec[1];
	cout &lt;&lt; "vec.at(0)：" &lt;&lt; *vec.at(0) &lt;&lt; endl;
	cout &lt;&lt; "vec[1]：" &lt;&lt; *vec[1] &lt;&lt; endl;


	// 弊端3.不支持对象数组的内存管理
	//auto_ptr&lt;int[]&gt; array(new int[5]);	// 不能这样定义
	return 0;
} 


</code></pre>
<p>三、unique_ptr<br>
auto_ptr 是用于 C++11 之前的智能指针。由于 auto_ptr 基于排他所有权模式：两个指针不能指向同一个资源，复制或赋值都会改变资源的所有权。auto_ptr 主要有三大问题：</p>
<p>复制和赋值会改变资源的所有权，不符合人的直觉。<br>
在 STL 容器中使用 auto_ptr 存在重大风险，因为容器内的元素必需支持可复制（copy constructable）和可赋值（assignable）。<br>
不支持对象数组的操作</p>
<ol>
<li><strong>所有权语义</strong>：
<ul>
<li><code>auto_ptr</code>  使用独占所有权语义，即一个  <code>auto_ptr</code>  指针拥有对其所管理资源的唯一所有权。这意味着一个  <code>auto_ptr</code>  对象的所有权可以从一个对象转移到另一个对象，但不能共享资源。</li>
<li><code>unique_ptr</code>  也使用独占所有权语义，但它提供了更严格的所有权管理。例如， <code>unique_ptr</code>  的拷贝构造函数和赋值操作符都被删除了，因此不能像  <code>auto_ptr</code>  那样直接赋值或拷贝。相反， <code>unique_ptr</code>  只能通过移动来转移所有权。</li>
</ul>
</li>
<li><strong>删除拷贝构造函数和赋值操作符</strong>：
<ul>
<li>在  <code>unique_ptr</code>  中，拷贝构造函数和赋值操作符被显式地删除了，这意味着  <code>unique_ptr</code>  不能进行拷贝或赋值操作，只能通过移动语义来转移资源的所有权。</li>
<li><code>auto_ptr</code>  允许拷贝和赋值，但它的拷贝语义并不安全，可能会导致悬空指针问题。</li>
</ul>
</li>
<li><strong>自定义删除器</strong>：
<ul>
<li><code>unique_ptr</code>  允许你指定一个自定义删除器，用于释放资源时的操作。这使得  <code>unique_ptr</code>  可以管理动态分配的数组以及其他需要特殊处理的资源。</li>
<li><code>auto_ptr</code>  没有提供类似的功能，它只能用于管理单个动态分配的对象。</li>
</ul>
</li>
</ol>
<p>综上所述，虽然  <code>unique_ptr</code>  和  <code>auto_ptr</code>  在某些方面类似，但由于  <code>unique_ptr</code>  提供了更严格的所有权管理和更安全的拷贝语义，因此在 C++11 中推荐使用  <code>unique_ptr</code> ，而不是  <code>auto_ptr</code> 。</p>
<pre><code>unique_ptr&lt;string&gt; p1(new string("I'm Li Ming!"));
unique_ptr&lt;string&gt; p2(new string("I'm age 22."));
	
cout &lt;&lt; "p1：" &lt;&lt; p1.get() &lt;&lt; endl;
cout &lt;&lt; "p2：" &lt;&lt; p2.get() &lt;&lt; endl;

p1 = p2;					// 禁止左值赋值
unique_ptr&lt;string&gt; p3(p2);	// 禁止左值赋值构造

unique_ptr&lt;string&gt; p3(std::move(p1));
p1 = std::move(p2);	// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样

cout &lt;&lt; "p1 = p2 赋值后：" &lt;&lt; endl;
cout &lt;&lt; "p1：" &lt;&lt; p1.get() &lt;&lt; endl;
cout &lt;&lt; "p2：" &lt;&lt; p2.get() &lt;&lt; endl;

</code></pre>
<p>参考图片</p>
<p><img loading="lazy" data-src="C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240303154043937.png" alt="image-20240303154043937"></p>
<p><strong>B</strong>. 在 STL 容器中使用 unique_ptr，不允许直接赋值</p>
<pre><code>vector&lt;unique_ptr&lt;string&gt;&gt; vec;
unique_ptr&lt;string&gt; p3(new string("I'm P3"));
unique_ptr&lt;string&gt; p4(new string("I'm P4"));

vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

cout &lt;&lt; "vec.at(0)：" &lt;&lt; *vec.at(0) &lt;&lt; endl;
cout &lt;&lt; "vec[1]：" &lt;&lt; *vec[1] &lt;&lt; endl;

vec[0] = vec[1];	/* 不允许直接赋值 */
vec[0] = std::move(vec[1]);		// 需要使用move修饰，使得程序员知道后果

cout &lt;&lt; "vec.at(0)：" &lt;&lt; *vec.at(0) &lt;&lt; endl;
cout &lt;&lt; "vec[1]：" &lt;&lt; *vec[1] &lt;&lt; endl;


</code></pre>
<p>在 C++ 中， <code>std::move</code>  是一个函数模板，它用于将一个左值转换为右值引用，以便进行移动语义的操作。它并不执行移动操作，而只是告诉编译器你有意进行移动操作。</p>
<p><code>std::move</code>  的作用主要有两个方面：</p>
<ol>
<li><strong>标记对象为右值</strong>：使用  <code>std::move</code>  可以将一个左值转换为右值引用，告诉编译器你有意将其移动，而不是复制。这在实现移动语义时非常有用，因为移动语义通常比复制语义更高效。例如，当你将一个对象传递给接受右值引用的函数时，你可以使用  <code>std::move</code>  来传递对象的所有权，以便进行移动构造或移动赋值。</li>
<li><strong>避免不必要的拷贝</strong>：在某些情况下，对象的拷贝操作可能是不必要的，因为你知道这个对象在后续的使用中不再需要了。使用  <code>std::move</code>  可以避免不必要的拷贝，从而提高程序的性能。例如，在将一个对象放入容器中时，你可以使用  <code>std::move</code>  来移动对象，而不是复制对象。</li>
</ol>
<p>综上所述， <code>std::move</code>  的主要作用是将左值转换为右值引用，以便进行移动语义的操作，并且可以避免不必要的拷贝，提高程序的性能。但需要注意的是，使用  <code>std::move</code>  后，原始对象的状态会变为不确定的，因此在移动后，不要再对原始对象进行操作。</p>
<p>除了上面 ABC 三项外，unique_ptr 的其余用法都与 auto_ptr 用法一致。</p>
<pre><code>构造
class Test {
public:
	Test() { cout &lt;&lt; "Test的构造函数..." &lt;&lt; endl; }
	~Test() { cout &lt;&lt; "Test的析构函数..." &lt;&lt; endl; }

	void doSomething() { cout &lt;&lt; "do something......" &lt;&lt; endl; }
};


// 自定义一个内存释放其
class DestructTest {
	public:
	void operator()(Test *pt) {
		pt-&gt;doSomething();
		delete pt;
	}
};

// unique_ptr&lt;T&gt; up; 空的unique_ptr，可以指向类型为T的对象
unique_ptr&lt;Test&gt; t1;

// unique_ptr&lt;T&gt; up1(new T());	定义unique_ptr,同时指向类型为T的对象
unique_ptr&lt;Test&gt; t2(new Test);

// unique_ptr&lt;T[]&gt; up;	空的unique_ptr，可以指向类型为T[的数组对象
unique_ptr&lt;int[]&gt; t3;

// unique_ptr&lt;T[]&gt; up1(new T[]);	定义unique_ptr,同时指向类型为T的数组对象
unique_ptr&lt;int[]&gt; t4(new int[5]);

// unique_ptr&lt;T, D&gt; up();	空的unique_ptr，接受一个D类型的删除器D，使用D释放内存
unique_ptr&lt;Test, DestructTest&gt; t5;

// unique_ptr&lt;T, D&gt; up(new T());	定义unique_ptr,同时指向类型为T的对象，接受一个D类型的删除器D，使用删除器D来释放内存
unique_ptr&lt;Test, DestructTest&gt; t6(new Test);


赋值
unique_ptr&lt;Test&gt; t7(new Test);
unique_ptr&lt;Test&gt; t8(new Test);
t7 = std::move(t8);	// 必须使用移动语义，结果，t7的内存释放，t8的内存交给t7管理
t7-&gt;doSomething();


主动释放对象
unique_ptr&lt;Test&gt; t9(new Test);
t9 = NULL;
t9 = nullptr;
t9.reset();

放弃对象的控制权

Test *t10 = t9.release();
重置
t9.reset(new Test);


auto_ptr 与 unique_ptr智能指针的内存管理陷阱
auto_ptr&lt;string&gt; p1;
string *str = new string("智能指针的内存管理陷阱");
p1.reset(str);	// p1托管str指针
{
	auto_ptr&lt;string&gt; p2;
	p2.reset(str);	// p2接管str指针时，会先取消p1的托管，然后再对str的托管
}

// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！
cout &lt;&lt; "str：" &lt;&lt; *p1 &lt;&lt; endl;

</code></pre>
<p><img loading="lazy" data-src="https://img-blog.csdnimg.cn/6b0a0e1ec3984107a1787671c7cad0fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这是由于 auto_ptr 与 unique_ptr 的排他性所导致的！<br>
<strong>为了解决这样的问题，我们可以使用 shared_ptr 指针指针</strong></p>
<p><code>std::shared_ptr</code>  是 C++ 标准库中的智能指针，用于管理动态分配的资源，并提供了共享所有权的语义。它允许多个智能指针共享同一个对象，而不会造成资源重复释放或悬空指针的问题。</p>
<p><code>std::shared_ptr</code>  的主要特点包括：</p>
<ol>
<li><strong>共享所有权</strong>：多个  <code>std::shared_ptr</code>  对象可以指向同一个动态分配的对象，它们共享对该对象的所有权。只有当所有  <code>std::shared_ptr</code>  对象都释放了对该对象的所有权后，该对象才会被销毁。</li>
<li><strong>引用计数</strong>： <code>std::shared_ptr</code>  内部维护了一个引用计数，用于记录有多少个  <code>std::shared_ptr</code>  对象共享同一个动态分配的对象。每次创建、拷贝、移动或销毁  <code>std::shared_ptr</code>  对象时，引用计数都会相应地增加、减少或清零。</li>
<li><strong>自动释放资源</strong>：当引用计数减少到零时， <code>std::shared_ptr</code>  会自动释放所管理的资源，即调用动态分配对象的析构函数，并释放对象所占用的内存。</li>
<li><strong>线程安全的引用计数</strong>： <code>std::shared_ptr</code>  内部的引用计数是线程安全的，因此多个线程可以安全地共享同一个  <code>std::shared_ptr</code>  对象。</li>
<li><strong>循环引用问题</strong>： <code>std::shared_ptr</code>  的共享所有权特性可能导致循环引用问题，即两个或多个对象相互持有对方的  <code>std::shared_ptr</code>  对象，导致资源永远无法释放。为了避免这种情况，可以使用  <code>std::weak_ptr</code>  来解决循环引用问题。</li>
</ol>
<p>总的来说， <code>std::shared_ptr</code>  是一种非常灵活和安全的智能指针，适用于多个对象需要共享同一个资源的情况。它提供了自动释放资源、引用计数、线程安全等特性，能够有效地管理动态分配的资源，并避免内存泄漏和悬空指针问题。</p>
<pre><code>
class Person {
public:
	Person(int v) {
		this-&gt;no = v;
		cout &lt;&lt; "构造函数 \t no = " &lt;&lt; this-&gt;no &lt;&lt; endl;
	}

	~Person() {
		cout &lt;&lt; "析构函数 \t no = " &lt;&lt; this-&gt;no &lt;&lt; endl;
	}

private:
	int no;
};

// 仿函数，内存删除
class DestructPerson {
public:
	void operator() (Person *pt) {
		cout &lt;&lt; "DestructPerson..." &lt;&lt; endl;
		delete pt;
	}
};


引用计数的使用

调用use_count函数可以获得当前托管指针的引用计数。

shared_ptr&lt;Person&gt; sp1;

shared_ptr&lt;Person&gt; sp2(new Person(2));

// 获取智能指针管控的共享指针的数量	use_count()：引用计数
cout &lt;&lt; "sp1	use_count() = " &lt;&lt; sp1.use_count() &lt;&lt; endl;
cout &lt;&lt; "sp2	use_count() = " &lt;&lt; sp2.use_count() &lt;&lt; endl &lt;&lt; endl;

// 共享
sp1 = sp2;

cout &lt;&lt; "sp1	use_count() = " &lt;&lt; sp1.use_count() &lt;&lt; endl;
cout &lt;&lt; "sp2	use_count() = " &lt;&lt; sp2.use_count() &lt;&lt; endl &lt;&lt; endl;

shared_ptr&lt;Person&gt; sp3(sp1);
cout &lt;&lt; "sp1	use_count() = " &lt;&lt; sp1.use_count() &lt;&lt; endl;
cout &lt;&lt; "sp2	use_count() = " &lt;&lt; sp2.use_count() &lt;&lt; endl;
cout &lt;&lt; "sp2	use_count() = " &lt;&lt; sp3.use_count() &lt;&lt; endl &lt;&lt; endl;


如上代码，sp1 = sp2; 和 shared_ptr&lt; Person &gt; sp3(sp1);就是在使用引用计数了。

sp1 = sp2; --&gt; sp1和sp2共同托管同一个指针，所以他们的引用计数为2；
shared_ptr&lt; Person &gt; sp3(sp1); --&gt; sp1和sp2和sp3共同托管同一个指针，所以他们的引用计数为3；
构造
 shared_ptr&lt; T &gt; sp1; 空的shared_ptr，可以指向类型为T的对象
shared_ptr&lt;Person&gt; sp1;
Person *person1 = new Person(1);
sp1.reset(person1);	// 托管person1

 shared_ptr&lt; T &gt; sp2(new T()); 定义shared_ptr,同时指向类型为T的对象
 shared_ptr&lt;Person&gt; sp2(new Person(2));
shared_ptr&lt;Person&gt; sp3(sp1);

shared_ptr&lt;T[]&gt; sp4; 空的shared_ptr，可以指向类型为T[]的数组对象 C++17后支持
shared_ptr&lt;Person[]&gt; sp4;


shared_ptr&lt;T[]&gt; sp5(new T[] { … }); 指向类型为T的数组对象 C++17后支持
shared_ptr&lt;Person[]&gt; sp5(new Person[5] { 3, 4, 5, 6, 7 });



 shared_ptr&lt; T &gt; sp6(NULL, D()); //空的shared_ptr，接受一个D类型的删除器，使用D释放内存
 shared_ptr&lt;Person&gt; sp6(NULL, DestructPerson());

. shared_ptr&lt; T &gt; sp7(new T(), D()); //定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存
shared_ptr&lt;Person&gt; sp7(new Person(8), DestructPerson());



                            
https://blog.csdn.net/cpp_learner/article/details/118912592
</code></pre>
<h4 id="初始化"><a class="anchor" href="#初始化">#</a> 初始化</h4>
<ul>
<li>
<p><strong>1).</strong> 方式一：构造函数</p>
<pre><code>shared_ptr&lt;int&gt; up1(new int(10));  // int(10) 的引用计数为1
shared_ptr&lt;int&gt; up2(up1);  // 使用智能指针up1构造up2, 此时int(10) 引用计数为2

</code></pre>
</li>
<li>
<p>方式二：使用 make_shared 初始化对象，分配内存效率更高 (推荐使用)<br>
 make_shared 函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr; 用法：<br>
make_shared &lt;类型&gt;(构造类型对象需要的参数列表);</p>
<pre><code>shared_ptr&lt;int&gt; up3 = make_shared&lt;int&gt;(2); // 多个参数以逗号','隔开，最多接受十个
shared_ptr&lt;string&gt; up4 = make_shared&lt;string&gt;("字符串");
shared_ptr&lt;Person&gt; up5 = make_shared&lt;Person&gt;(9);

</code></pre>
</li>
</ul>
<p>4 赋值</p>
<pre><code>shared_ptrr&lt;int&gt; up1(new int(10));  // int(10) 的引用计数为1
shared_ptr&lt;int&gt; up2(new int(11));   // int(11) 的引用计数为1
up1 = up2;	// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2

</code></pre>
<p><strong>主动释放对象</strong></p>
<pre><code>shared_ptrr&lt;int&gt; up1(new int(10));
up1 = nullptr ;	// int(10) 的引用计数减1,计数归零内存释放 
// 或
up1 = NULL; // 作用同上 

</code></pre>
<p><strong>重置</strong></p>
<pre><code>p.reset() ; 将p重置为空指针，所管理对象引用计数 减1
p.reset(p1); 将p重置为p1（的值）,p 管控的对象计数减1，p接管对p1指针的管控
p.reset(p1,d); 将p重置为p1（的值），p 管控的对象计数减1并使用d作为删除器
p1是一个指针！
</code></pre>
<p><strong>交换</strong></p>
<pre><code>p1 和 p2 是智能指针

std::swap(p1,p2); // 交换p1 和p2 管理的对象，原对象的引用计数不变
p1.swap(p2);    // 交换p1 和p2 管理的对象，原对象的引用计数不变
</code></pre>
<h3 id="shared_ptr使用陷阱"><a class="anchor" href="#shared_ptr使用陷阱">#</a> shared_ptr 使用陷阱</h3>
<p>shared_ptr 作为被管控的对象的成员时，小心因循环引用造成无法释放资源！</p>
<p>如下代码：<br>
Boy 类中有 Girl 的智能指针；<br>
Girl 类中有 Boy 的智能指针；<br>
当他们交叉互相持有对方的管理对象时…</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

using namespace std;

class Girl;

class Boy {
public:
	Boy() {
		cout &lt;&lt; "Boy 构造函数" &lt;&lt; endl;
	}

	~Boy() {
		cout &lt;&lt; "~Boy 析构函数" &lt;&lt; endl;
	}

	void setGirlFriend(shared_ptr&lt;Girl&gt; _girlFriend) {
		this-&gt;girlFriend = _girlFriend;
	}

private:
	shared_ptr&lt;Girl&gt; girlFriend;
};

class Girl {
public:
	Girl() {
		cout &lt;&lt; "Girl 构造函数" &lt;&lt; endl;
	}

	~Girl() {
		cout &lt;&lt; "~Girl 析构函数" &lt;&lt; endl;
	}

	void setBoyFriend(shared_ptr&lt;Boy&gt; _boyFriend) {
		this-&gt;boyFriend = _boyFriend;
	}

private:
	shared_ptr&lt;Boy&gt; boyFriend;
};


void useTrap() {
	shared_ptr&lt;Boy&gt; spBoy(new Boy());
	shared_ptr&lt;Girl&gt; spGirl(new Girl());

	// 陷阱用法
	spBoy-&gt;setGirlFriend(spGirl);
	spGirl-&gt;setBoyFriend(spBoy);
	// 此时boy和girl的引用计数都是2
}


int main(void) {
	useTrap();

	system("pause");
	return 0;
}


</code></pre>
<p>这段代码存在一个循环引用的问题，导致  <code>Boy</code>  对象和  <code>Girl</code>  对象互相持有对方的  <code>shared_ptr</code> ，从而导致了内存泄漏，因为它们的引用计数永远不会变为 0。</p>
<p>具体来说，当  <code>useTrap()</code>  函数执行时，首先创建了一个  <code>shared_ptr&lt;Boy&gt;</code>  对象  <code>spBoy</code>  和一个  <code>shared_ptr&lt;Girl&gt;</code>  对象  <code>spGirl</code> 。然后，通过  <code>spBoy-&gt;setGirlFriend(spGirl)</code>  和  <code>spGirl-&gt;setBoyFriend(spBoy)</code>  分别将  <code>spGirl</code>  和  <code>spBoy</code>  传递给对方，这样就产生了循环引用的问题： <code>Boy</code>  对象持有  <code>Girl</code>  对象的  <code>shared_ptr</code> ，而  <code>Girl</code>  对象持有  <code>Boy</code>  对象的  <code>shared_ptr</code> 。因此，它们的引用计数都变成了 2，而不会减少到 0，导致它们的析构函数永远不会被调用，从而造成了内存泄漏。</p>
<p>为了解决这个问题，可以使用  <code>weak_ptr</code>  来打破循环引用。 <code>weak_ptr</code>  是  <code>shared_ptr</code>  的一种弱引用，它可以监视  <code>shared_ptr</code>  的生命周期，但不会影响其引用计数。因此，可以将  <code>Girl</code>  类中的  <code>boyFriend</code>  成员改为  <code>weak_ptr&lt;Boy&gt;</code>  类型，从而避免循环引用的问题。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;

using namespace std;

class Girl;

class Boy {
public:
    Boy() {
        cout &lt;&lt; "Boy 构造函数" &lt;&lt; endl;
    }

    ~Boy() {
        cout &lt;&lt; "~Boy 析构函数" &lt;&lt; endl;
    }

    void setGirlFriend(shared_ptr&lt;Girl&gt; _girlFriend) {
        this-&gt;girlFriend = _girlFriend;
    }

private:
    weak_ptr&lt;Girl&gt; girlFriend;
};

class Girl {
public:
    Girl() {
        cout &lt;&lt; "Girl 构造函数" &lt;&lt; endl;
    }

    ~Girl() {
        cout &lt;&lt; "~Girl 析构函数" &lt;&lt; endl;
    }

    void setBoyFriend(shared_ptr&lt;Boy&gt; _boyFriend) {
        this-&gt;boyFriend = _boyFriend;
    }

private:
    weak_ptr&lt;Boy&gt; boyFriend;
};


void useTrap() {
    shared_ptr&lt;Boy&gt; spBoy(new Boy());
    shared_ptr&lt;Girl&gt; spGirl(new Girl());

    // 陷阱用法
    spBoy-&gt;setGirlFriend(spGirl);
    spGirl-&gt;setBoyFriend(spBoy);
    // 此时boy和girl的引用计数都是2
}


int main(void) {
    useTrap();

    system("pause");
    return 0;
}

</code></pre>
<p>当我们执行 useTrap 函数时，注意，是没有结束此函数，boy 和 girl 指针其实是被两个智能指针托管的，所以他们的引用计数是 2</p>
<p><img loading="lazy" data-src="https://img-blog.csdnimg.cn/f00ef1a424b2427cb7817c146bf28abb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>useTrap 函数结束后，函数中定义的智能指针被清掉，boy 和 girl 指针的引用计数减 1，还剩下 1，对象中的智能指针还是托管他们的，所以函数结束后没有将 boy 和 gilr 指针释放的原因就是于此</p>
<p><img loading="lazy" data-src="https://img-blog.csdnimg.cn/cd962cb9e0ae4610bebb40da2133e8a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>首先释放 spBoy，但是因为 girl 对象里面的智能指针还托管着 boy，boy 的引用计数为 2，所以释放 spBoy 时，引用计数减 1，boy 的引用计数为 1；<br>
在释放 spGirl，girl 的引用计数减 1，为零，开始释放 girl 的内存，因为 girl 里面还包含有托管 boy 的智能指针对象，所以也会进行 boyFriend 的内存释放，boy 的引用计数减 1，为零，接着开始释放 boy 的内存。最终所有的内存都释放了。</p>
<p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。 同时 weak_ptr 没有重载 * 和 -&gt; 但可以使用 lock 获得一个可用的 shared_ptr 对象。</p>
<p>弱指针的使用；<br>
weak_ptr wpGirl_1; // 定义空的弱指针<br>
 weak_ptr wpGirl_2 (spGirl); // 使用共享指针构造<br>
 wpGirl_1 = spGirl; // 允许共享指针赋值给弱指针</p>
<p>弱指针也可以获得引用计数；<br>
wpGirl_1.use_count()</p>
<p>您是对的。 <code>weak_ptr</code>  是一种弱引用，它并不直接支持解引用操作 ( <code>*</code>  和  <code>-&gt;</code> )，因为它并不拥有被指向对象的所有权。相反， <code>weak_ptr</code>  主要用于监视由  <code>shared_ptr</code>  管理的对象的生命周期，而不会增加对象的引用计数。</p>
<p>要访问  <code>weak_ptr</code>  所指向的对象，通常需要将  <code>weak_ptr</code>  转换为  <code>shared_ptr</code> 。可以通过  <code>lock()</code>  成员函数将  <code>weak_ptr</code>  转换为  <code>shared_ptr</code> ，然后使用  <code>shared_ptr</code>  的  <code>*</code>  和  <code>-&gt;</code>  运算符来访问所指向的对象。</p>
<p>以下是一个示例：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

using namespace std;

int main() {
    shared_ptr&lt;int&gt; sp(new int(42));
    weak_ptr&lt;int&gt; wp = sp;

    // 尝试解引用 weak_ptr
    //int val = *wp;  // 错误：weak_ptr 不支持直接解引用
    //cout &lt;&lt; "Value: " &lt;&lt; val &lt;&lt; endl;

    // 尝试通过 -&gt; 运算符访问 weak_ptr 所指向的对象
    //int val2 = wp-&gt;getValue(); // 错误：weak_ptr 不支持直接使用 -&gt; 运算符

    // 将 weak_ptr 转换为 shared_ptr
    shared_ptr&lt;int&gt; sp2 = wp.lock();
    if (sp2) {
        // 成功获取 shared_ptr，现在可以使用 * 和 -&gt; 运算符访问所指向的对象
        int val3 = *sp2;
        cout &lt;&lt; "Value: " &lt;&lt; val3 &lt;&lt; endl;
    } else {
        cout &lt;&lt; "The shared_ptr is expired." &lt;&lt; endl;
    }

    return 0;
}

</code></pre>
<p>在上面的示例中，我们使用了  <code>lock()</code>  函数将  <code>weak_ptr</code>  转换为  <code>shared_ptr</code> ，然后使用  <code>shared_ptr</code>  的  <code>*</code>  运算符来解引用  <code>shared_ptr</code>  对象并访问所指向的对象的值。这样做的好处是，在转换为  <code>shared_ptr</code>  时，我们同时增加了被指向对象的引用计数，确保在  <code>shared_ptr</code>  存活期间对象不会被销毁。</p>
<p>expired 函数的用法<br>
应评论区某位朋友的要求，现在加上 weak_ptr 指针的 expired 函数的用法！</p>
<p>expired：判断当前 weak_ptr 智能指针是否还有托管的对象，有则返回 false，无则返回 true</p>
<p>如果返回 true，等价于 use_count () == 0，即已经没有托管的对象了；当然，可能还有析构函数进行释放内存，但此对象的析构已经临近（或可能已发生）。</p>
<p>示例<br>
演示如何用 expired 检查指针的合法性。<br>
在网上找了一段代码，加上自己的注释理解</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

std::weak_ptr&lt;int&gt; gw;

void f() {

	// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true
	if (!gw.expired()) {
		std::cout &lt;&lt; "gw is valid\n";	// 有效的，还有托管的指针
	} else {
		std::cout &lt;&lt; "gw is expired\n";	// 过期的，没有托管的指针
	}
}

int main() {
	{
		auto sp = std::make_shared&lt;int&gt;(42);
		gw = sp;

		f();
	}

	// 当{ }体中的指针生命周期结束后，再来判断其是否还有托管的指针
	f();

	return 0;
}

</code></pre>
<p>六、智能指针的使用陷阱<br>
不要把一个原生指针给多个智能指针管理；</p>
<p>int *x = new int(10);<br>
unique_ptr&lt; int &gt; up1(x);<br>
unique_ptr&lt; int &gt; up2(x);<br>
// 警告！以上代码使 up1 up2 指向同一个内存，非常危险<br>
或以下形式：<br>
up1.reset(x);<br>
up2.reset(x);</p>
<p>记得使用 u.release () 的返回值；<br>
 在调用 u.release () 时是不会释放 u 所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就泄漏了.</p>
<p>禁止 delete 智能指针 get 函数返回的指针；<br>
 如果我们主动释放掉 get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放，带来严重后果！</p>
<p>禁止用任何类型智能指针 get 函数返回的指针去初始化另外一个智能指针！<br>
shared_ptr&lt; int &gt; sp1(new int(10));<br>
// 一个典型的错误用法 shared_ptr&lt;int&gt; sp4 (sp1.get ());<br>
————————————————</p>
<pre><code>                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
</code></pre>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/cpp_learner/article/details/118912592">https://blog.csdn.net/cpp_learner/article/details/118912592</a></p>
<p>智能指针虽然使用起来很方便，但是要注意使用智能指针的一些陷阱，否则会造成严重的内存报错或者内存泄露等问题！</p>
<p>某最大矩阵写的暴力</p>
<pre><code class="language-c++">#include &lt;vector&gt;
using namespace std;

class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        int n = matrix.size();
        if (n == 0) return 0;
        int m = matrix[0].size();
        if (m == 0) return 0;

        // 将字符矩阵转换为整数矩阵
        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0));
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                f[i][j] = matrix[i - 1][j - 1] - '0';

        int ans = 0;

        // 先更新前缀和
        for (int i = 1; i &lt;= n; i++)
            for (int j = 1; j &lt;= m; j++)
                f[i][j] += f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1];

        for (int i = 1; i &lt;= n; i++) {
            for (int j = 1; j &lt;= m; j++) {
                // 确定一个点，枚举边长
                for (int k = 1; k &lt;= min(n - i + 1, m - j + 1); k++) {
                    // 枚举边长
                    int x1 = i, x2 = i + k - 1, y1 = j, y2 = j + k - 1;
                    // 确定四个点
                    int sum = f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1];
                    // 计算面积
                    if (sum == k * k)
                        ans = max(ans, sum);
                    if (sum != k * k)
                        break;
                    // 更新答案
                }
            }
        }

        return ans;
    }
};

</code></pre>
<h3 id="神奇的dp"><a class="anchor" href="#神奇的dp">#</a> 神奇的 DP</h3>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">編集日</span><time title="修正日：2024-03-03 16:41:03" itemprop="dateModified" datetime="2024-03-03T16:41:03+08:00">2024-03-03</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>寄付</button><p>*~(￣▽￣)~[お茶]を一杯ください</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.webp" alt="lystics WeChat 支払う"><p>WeChat 支払う</p></div><div><img loading="lazy" data-src="/assets/alipay.webp" alt="lystics Alipay"><p>Alipay</p></div></div></div><div id="copyright"><ul><li class="author"><strong>著者：</strong>lystics<i class="ic i-at"><em>@</em></i>Lystics</li><li class="link"><strong>記事へのリンク：</strong><a href="https://lysistic.github.io/2024/03/03/cpp-O-o/" title="cpp_O.o">https://lysistic.github.io/2024/03/03/cpp-O-o/</a></li><li class="license"><strong>著作権表示：</strong>このブログ内のすべての記事は、特別な記載がない限り <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> の下のライセンスで保護されています。</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/03/03/hello-world/" rel="prev" itemprop="url" data-background-image="https://lysistic.github.io/image/img/img(30).webp" title="Hello World"><span class="type">前の記事</span><h3>Hello World</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="見出し"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.</span> <span class="toc-text"> 智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#auto_ptr"><span class="toc-number">1.1.</span> <span class="toc-text"> auto_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#auto_ptr-%E8%A2%ABc11%E6%8A%9B%E5%BC%83%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.1.1.</span> <span class="toc-text"> auto_ptr 被 C++11 抛弃的主要原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared_ptr%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1"><span class="toc-number">1.1.2.</span> <span class="toc-text"> shared_ptr 使用陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E7%9A%84dp"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 神奇的 DP</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="関連記事"></div><div class="overview panel" data-title="概要"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="lystics" src="/assets/avatar.webp"><p class="name" itemprop="name">lystics</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">4</span><span class="name">ポスト</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/lysistic" class="item github" title="https://github.com/lysistic"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>ホーム</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>フレンド</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/03/03/hello-world/" rel="next" title="次の記事"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>ランダムな記事</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2024/02/12/my-first-article/">my first article</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/03/cpp-O-o/">cpp_O.o</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/03/git-learn/">git-learn</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/03/hello-world/">Hello World</a></span></li></ul></div><div class="rpost pjax"><h2>最近のコメント</h2></div></div><div class="status"><div class="copyright">© 2022 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">lystics @ Hust_CSE_undergraduate</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="単語の総数">30k 単語</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="読書の合計時間">27 分</span></div><div class="powered-by">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> &amp; Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config="" type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2024/03/03/cpp-O-o/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "検索…",
        empty: "「 ${query} 」については何も見つかりませんでした",
        stats: "${time} ms以内に ${hits} 件の結果が見つかりました"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">記事の適時性の警告</span><br> {{publish}} 日前に公開され、 {{updated}} 日前に最終更新された記事です。 一部情報が変更されている可能性がありますので、ご了承ください。</p></div>`,
    quiz: {
        choice: `選択`,
        multiple: `複数選択`,
        true_false: `正誤`,
        essay: `問答`,
        gap_fill: `空欄`,
        mistake: `間違った答え`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.2.4/pace.min.js" async=""></script><script src="/js/siteInit.js?v=0.4.2" type="module" fetchpriority="high" defer=""></script></body></html>