{
    "version": "https://jsonfeed.org/version/1",
    "title": "Lystics",
    "subtitle": "",
    "icon": "https://lysistic.github.io/assets/favicon.ico",
    "description": "",
    "home_page_url": "https://lysistic.github.io",
    "items": [
        {
            "id": "https://lysistic.github.io/2024/03/04/number-theory/",
            "url": "https://lysistic.github.io/2024/03/04/number-theory/",
            "title": "number_theory",
            "date_published": "2024-03-04T00:54:19.000Z",
            "content_html": "<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304085613751.png\" alt=\"image-20240304085613751\" /></p>\n<ul>\n<li>b 可被 a 整除，b 是 a 的倍数，a 是 b 的因子。</li>\n</ul>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304090047739.png\" alt=\"image-20240304090047739\" /></p>\n<ul>\n<li>两数满足整除关系，正负绝对值之间都满足，整除是数值大小上的一种特性</li>\n<li>a 是 b 的因子，b 是 c 的因子，a 自然是 ca 的因子</li>\n<li>a 是 b 的因子的同时 a 是 c 的因子，所以 a 是 b 和 c 的任意线性组合的因子</li>\n<li>a 整除 b 的同时 b 整除 a，那么 a 和 b 的绝对值相等</li>\n<li>如果 a 整除 b，a 和 b 的非零倍数也满足关系</li>\n<li>a|b,b 是否等于零是一个特殊情况，如果 b 不等于零，那么 a 的绝对值小于等于 b 的绝对值。也就是说 a|b，要么 b 等于零 a 的绝对值大于等于 b，要么 a 的绝对值小于等于 b</li>\n<li>如果 a 不等于 0，a 不能整除 b，也就是说 b 等于 a 的某个倍数加上一个余数 c，那么 a|b=a|c, 也就是 b 和 c 在模 a 下同余</li>\n<li>a|b,b 是 a 的倍数，a 是 b 的约数</li>\n<li>0 是所有非零整数的倍数，非零倍数的约束是有限个，且一定可以写成不同个质数的某幂次的积</li>\n<li>平凡约数，对于一个不为零的整数 b，+1，-1，+b，-b 是其平凡约数，b 的其他约数称为真约数</li>\n<li><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304093544500.png\" alt=\"image-20240304093544500\" /></li>\n</ul>\n<p>约数描述的关系是相互的，这是一个闭包，也就是从前到后和从后到前，所以缩小复杂度可以从根号处判断</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304093720894.png\" alt=\"image-20240304093720894\" /></p>\n<p>带余数的除法，这里的余数不是我们理解的那个除不尽的余数，这个就是字面意思上的一个平移补充项。余数为 r，这里说 b 可以描述为 a 的多少倍，r 是 b 和 a 的 q 倍的差值。自然的可以想到 r 可以描述为 ma+r0. 无论整数 d 取多少，都能找到余数 r，也就是说保证余数 r 在 d 到 a+d 之间。因为 r0+ka，不断遍历 k 找到第一个大于 d 的数就行了。</p>\n<p>无论 d 取多少，这么说吧 b 和 r 在模 a 的意义下同余。</p>\n<p>绝对最小余数，d 取 a 绝对值一半的相反数。那么这个余数就在</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304102755600.png\" alt=\"image-20240304102755600\" /></p>\n<p>当 d 取零时，就是我们一般意义下的带余除法，这里的余数 r 称为最小非负余数</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304103003557.png\" alt=\"image-20240304103003557\" /></p>\n<p>带余除法的性质</p>\n<ul>\n<li>\n<p>任一整数被正整数 a 除后，余数一定是且仅是 0 到 a-1 这 a 个数中的一个</p>\n</li>\n<li>\n<p>相邻的 a 个整数被正整数 a 除后，恰好取到上述 a 个余数，特别的，一定有且仅有一个数被 a 整除。（区间唯一性）</p>\n</li>\n<li>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304103545996.png\" alt=\"image-20240304103545996\" /></p>\n</li>\n</ul>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304103607016.png\" alt=\"image-20240304103607016\" /></p>\n<p>设整数 p 不等于 0，正负 1，如果 p 除了平凡约束意外没有其他约数，那么称 p 为素数。（不可约数）</p>\n<p>a 不是素数，则称 a 为合数</p>\n<p>素数与合数的简单性质</p>\n<p>合数可以描述为两个整数的乘积</p>\n<p>对于合数 a 一定存在素数 p<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>≤</mo><msqrt><mi>a</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\leq\\sqrt{a}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.7719em;vertical-align:-0.136em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">a</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span></span></span></span>​</p>\n<p>如果有大于 1 的约数，那么这个约数是他自己</p>\n<p>合数一定可以分解为若干个质数</p>\n<p>素数有无穷多个</p>\n<p>所有大于 3 的素数都可以表示为 6n+1 的形式</p>\n<p>算数基本引理，p 整除 a1a2，那么 p 一定是 a1 的约数或者 a2 的约数</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304105843977.png\" alt=\"image-20240304105843977\" /></p>\n<p>标准素数分解式</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304110122252.png\" alt=\"image-20240304110122252\" /></p>\n<p>b 是 a 模 m 的剩余</p>\n<p>最小非负剩余，绝对最小剩余，最小正剩余</p>\n<p>同余的性质：</p>\n<p>自反性、对称性、传递性，以及支持线性运算不变性</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304115412271.png\" alt=\"image-20240304115412271\" /></p>\n<hr />\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304115539249.png\" alt=\"image-20240304115539249\" /></p>\n<p>相对复杂，限制更强</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080724341.png\" alt=\"image-20240305080724341\" /><br />\n 更精细更小的生成元仍然满足</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080751971.png\" alt=\"image-20240305080751971\" /></p>\n<p>a 和 b 对 m 同余，那么 a 和 m 的最大公约数和 b 和 m 的最大公约数相等</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080837855.png\" alt=\"image-20240305080837855\" /></p>\n<p>d 能整除 m 且 d 能整除 a 和 b 中的一个 ----------&gt;d 能整除 a 和 b 中的另一个</p>\n<p>积性函数</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305080952566.png\" alt=\"image-20240305080952566\" /></p>\n<p>互质的满足乘法同态，当任意都满足则成为完全积性函数</p>\n<ul>\n<li><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305081145805.png\" alt=\"image-20240305081145805\" /></li>\n<li>完全积性的话自己和自己也能拆，就是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo>∗</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>f</mi><mn>2</mn></msup><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(x*x)=f(x)*f(x)=f^2(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<p>素数记数函数，小于或等于 x 的素数的个数，用<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>π</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\pi(x)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">π</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span></span></span></span> 来表示，随着其增大，近似于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mi>x</mi><mrow><mi>l</mi><mi>n</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{x}{ln(x)}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.2154em;vertical-align:-0.52em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6954em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mopen mtight\">(</span><span class=\"mord mathnormal mtight\">x</span><span class=\"mclose mtight\">)</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.52em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></p>\n<pre><code>def isPrime(a):\n    if a &lt; 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            return False\n    return True\n</code></pre>\n<p>暴力做法直接枚举</p>\n<p>不难发现检验 [2,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mi>a</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{a}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">a</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span></span></span></span>] 内的数就可以</p>\n<p>素性测试有两种，确定性测试和概率性测试，常见的包括 Lucas-Lehmer 测试和椭圆曲线素性证明。</p>\n<p>概率性测试：通常比确定性测试快很多，但有可能寄，通过概率性测试的数字被称为可能素数，而通过确定性测试的合数被称为伪素数，最常见的类型是费马伪素数。概率性测试的常见事例包括 Miller-Rabin 测试</p>\n<p>Fermat 素性测试</p>\n<p>Fermat 素性检验是一种简单的概率素性检验</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082141914.png\" alt=\"image-20240305082141914\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082223623.png\" alt=\"image-20240305082223623\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082309065.png\" alt=\"image-20240305082309065\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082357670.png\" alt=\"image-20240305082357670\" /></p>\n<p><strong>Miller–Rabin 素性测试</strong>（Miller–Rabin primality test）是进阶的素数判定方法。它是由 Miller 和 Rabin 二人根据费马小定理的逆定理（费马测试）优化得到的。因为和许多类似算法一样，它是使用伪素数的概率性测试，我们必须使用慢得多的确定性算法来保证素性。然而，实际上没有已知的数字通过了高级概率性测试（例如 Miller–Rabin）但实际上却是复合的。因此我们可以放心使用。</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305082511735.png\" alt=\"image-20240305082511735\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305083007839.png\" alt=\"image-20240305083007839\" /></p>\n<p>除了之前提到的性质外，卡迈尔数还有一些其他的数学性质：</p>\n<ol>\n<li><strong>平方数性质：</strong> 卡迈尔数不能是平方数。因为如果一个数是平方数，那么它的所有质因数的指数都是偶数，这与卡迈尔数的定义相矛盾。</li>\n<li><strong>半素数性质：</strong> 卡迈尔数不能是半素数，即不能表示为两个不同素数的乘积。这是因为如果一个数是半素数，它的所有质因数的指数都是 1，而卡迈尔数的质因数必须至少有一个指数大于 1，以满足费马小定理。</li>\n<li><strong>孪生卡迈尔数：</strong> 存在一些卡迈尔数的 “孪生对”，即两个卡迈尔数相差一个数。这类似于孪生素数对，但卡迈尔数的孪生对相对稀有得多。</li>\n<li><strong>连续卡迈尔数：</strong> 有一些情况下，连续的整数可能都是卡迈尔数，这种情况在数论中被称为 “卡迈尔链”。</li>\n<li><strong>卡迈尔数的分布：</strong> 卡迈尔数的分布性质在数论中是一个有趣的研究课题，虽然它们比素数更稀有，但它们的分布情况仍然是一个开放的问题。</li>\n</ol>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>将</mtext><msup><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width=\"1em\"/><mo stretchy=\"false\">(</mo><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow><mspace width=\"0.3333em\"/><mi>n</mi><mo stretchy=\"false\">)</mo><mtext>中的指数</mtext><mi>n</mi><mo>−</mo><mn>1</mn><mtext>分解为</mtext><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mi>u</mi><mo>×</mo><msup><mn>2</mn><mi>t</mi></msup><mtext>，在每轮测试中对随机出来的</mtext><mi>a</mi><mtext>先求出</mtext><mi>v</mi><mo>=</mo><msup><mi>a</mi><mi>u</mi></msup><mtext> </mtext><mo lspace=\"0.22em\" rspace=\"0.22em\"><mrow><mi mathvariant=\"normal\">m</mi><mi mathvariant=\"normal\">o</mi><mi mathvariant=\"normal\">d</mi></mrow></mo><mtext> </mtext><mi>n</mi><mtext>，之后对这个值执行最多</mtext><mi>t</mi><mtext>次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则再使用</mtext><mi>F</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>t</mi><mtext>素性测试判断。</mtext></mrow><annotation encoding=\"application/x-tex\">将 a^{n-1} \\equiv 1 \\pmod n 中的指数 n−1 分解为 n−1=u \\times 2^t，在每轮测试中对随机出来的 a 先求出 v = a^{u} \\bmod n，之后对这个值执行最多 t 次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则再使用 Fermat 素性测试判断。\n\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8641em;\"></span><span class=\"mord cjk_fallback\">将</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">≡</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace allowbreak\"></span><span class=\"mspace\" style=\"margin-right:1em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.3333em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">中的指数</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7667em;vertical-align:-0.0833em;\"></span><span class=\"mord\">1</span><span class=\"mord cjk_fallback\">分解为</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6667em;vertical-align:-0.0833em;\"></span><span class=\"mord mathnormal\">u</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8436em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8436em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">t</span></span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">，在每轮测试中对随机出来的</span><span class=\"mord mathnormal\">a</span><span class=\"mord cjk_fallback\">先求出</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7144em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7144em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">u</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\"><span class=\"mord\"><span class=\"mord mathrm\">mod</span></span></span><span class=\"mspace\" style=\"margin-right:0.0556em;\"></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord cjk_fallback\">，之后对这个值执行最多</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">次平方操作，若发现非平凡平方根时即可判断出其不是素数，否则再使用</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">er</span><span class=\"mord mathnormal\">ma</span><span class=\"mord mathnormal\">t</span><span class=\"mord cjk_fallback\">素性测试判断。</span></span></span></span></span></p>\n<p>这种方法是一种改进的素性测试算法，结合了二次探测定理中的指数分解以及费马素性测试的思想。下面是这个算法的基本步骤：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow></mrow><annotation encoding=\"application/x-tex\">\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"></span></span></span></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084022187.png\" alt=\"image-20240305084022187\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084041922.png\" alt=\"image-20240305084041922\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084106107.png\" alt=\"image-20240305084106107\" /></p>\n<pre><code>def millerRabin(n):\n    if n &lt; 3 or n % 2 == 0:\n        return n == 2\n    u, t = n - 1, 0\n    while u % 2 == 0:\n        u = u // 2\n        t = t + 1\n    # test_time 为测试次数,建议设为不小于 8\n    # 的整数以保证正确率,但也不宜过大,否则会影响效率\n    for i in range(test_time):\n        a = random.randint(2, n - 1)\n        v = pow(a, u, n)\n        if v == 1:\n            continue\n        s = 0\n        while s &lt; t:\n            if v == n - 1:\n                break\n            v = v * v % n\n            s = s + 1\n        # 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t\n        # 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1\n        if s == t:\n            return False\n    return True\n\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084510922.png\" alt=\"image-20240305084510922\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305084815004.png\" alt=\"image-20240305084815004\" /></p>\n<pre><code>bool millerRabin(int n) &#123;\n  if (n &lt; 3 || n % 2 == 0) return n == 2;\n  int u = n - 1, t = 0;\n  while (u % 2 == 0) u /= 2, ++t;\n  // test_time 为测试次数，建议设为不小于 8\n  // 的整数以保证正确率，但也不宜过大，否则会影响效率\n  for (int i = 0; i &lt; test_time; ++i) &#123;\n    int a = rand() % (n - 2) + 2, v = quickPow(a, u, n);\n    if (v == 1) continue;\n    int s;\n    for (s = 0; s &lt; t; ++s) &#123;\n      if (v == n - 1) break;  // 得到平凡平方根 n-1，通过此轮测试\n      v = (long long)v * v % n;\n    &#125;\n    // 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t\n    // 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1\n    if (s == t) return 0;\n  &#125;\n  return 1;\n&#125;\n</code></pre>\n<pre><code>def millerRabin(n):\n    if n &lt; 3 or n % 2 == 0:\n        return n == 2\n    u, t = n - 1, 0\n    while u % 2 == 0:\n        u = u // 2\n        t = t + 1\n    # test_time 为测试次数,建议设为不小于 8\n    # 的整数以保证正确率,但也不宜过大,否则会影响效率\n    for i in range(test_time):\n        a = random.randint(2, n - 1)\n        v = pow(a, u, n)\n        if v == 1:\n            continue\n        s = 0\n        while s &lt; t:\n            if v == n - 1:\n                break\n            v = v * v % n\n            s = s + 1\n        # 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t\n        # 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1\n        if s == t:\n            return False\n    return True\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305091117898.png\" alt=\"image-20240305091117898\" /></p>\n<pre><code>import random\n\ndef power(x, y, p):\n    # 计算 x^y mod p\n    res = 1\n    x = x % p\n    while y &gt; 0:\n        if y &amp; 1:\n            res = (res * x) % p\n        y = y &gt;&gt; 1\n        x = (x * x) % p\n    return res\n\ndef miller_rabin(n, k):\n    # 如果 n &lt; 4，直接返回 True 或 False\n    if n &lt;= 1:\n        return False\n    if n &lt;= 3:\n        return True\n\n    # 计算 n-1 = d*2^r\n    r = 0\n    d = n - 1\n    while d % 2 == 0:\n        r += 1\n        d //= 2\n\n    # 进行 k 次检验\n    for _ in range(k):\n        a = random.randint(2, n - 2)\n        x = power(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(r - 1):\n            x = (x * x) % n\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\n# 示例：对 2^64 范围内的数进行 Miller-Rabin 素性检验\nbases = [2, 325, 9375, 28178, 450775, 9780504, 1795265022]\nnum = 999999999999999989\nif miller_rabin(num, 7):\n    print(num, &quot;is prime&quot;)\nelse:\n    print(num, &quot;is composite&quot;)\n\n</code></pre>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n\nusing namespace std;\n\nlong long power(long long x, long long y, long long p) &#123;\n    // 计算 x^y mod p\n    long long res = 1;\n    x = x % p;\n    while (y &gt; 0) &#123;\n        if (y &amp; 1) &#123;\n            res = (res * x) % p;\n        &#125;\n        y = y &gt;&gt; 1;\n        x = (x * x) % p;\n    &#125;\n    return res;\n&#125;\n\nbool miller_rabin(long long n, int k) &#123;\n    // 如果 n &lt; 4，直接返回 true 或 false\n    if (n &lt;= 1) return false;\n    if (n &lt;= 3) return true;\n\n    // 计算 n-1 = d*2^r\n    int r = 0;\n    long long d = n - 1;\n    while (d % 2 == 0) &#123;\n        r += 1;\n        d /= 2;\n    &#125;\n\n    // 进行 k 次检验\n    for (int i = 0; i &lt; k; ++i) &#123;\n        long long a = rand() % (n - 3) + 2;\n        long long x = power(a, d, n);\n        if (x == 1 || x == n - 1) continue;\n        for (int j = 0; j &lt; r - 1; ++j) &#123;\n            x = (x * x) % n;\n            if (x == n - 1) break;\n        &#125;\n        if (x != n - 1) return false;\n    &#125;\n    return true;\n&#125;\n\nint main() &#123;\n    // 示例：对 2^64 范围内的数进行 Miller-Rabin 素性检验\n    srand(time(NULL));\n    long long num = 999999999999999989LL;\n    if (miller_rabin(num, 7)) &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; is prime&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; num &lt;&lt; &quot; is composite&quot; &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n</code></pre>\n<p>如果某个正整数 n 满足如下条件，则称为是 <strong>反素数</strong>：任何小于 n 的正数的约数个数都小于 n 的约数个数</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305092039671.png\" alt=\"image-20240305092039671\" /></p>\n<p>神！调整分析法</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305092614528.png\" alt=\"image-20240305092614528\" /></p>\n<p>对于这种题，我们只要以因子数为 dfs 的返回条件基准，不断更新找到的最小值就可以了</p>\n<pre><code>#include &lt;stdio.h&gt;\nunsigned long long p[16] = &#123;\n    2,  3,  5,  7,  11, 13, 17, 19,\n    23, 29, 31, 37, 41, 43, 47, 53&#125;;  // 根据数据范围可以确定使用的素数最大为53\n\nunsigned long long ans;\nunsigned long long n;\n\n// depth: 当前在枚举第几个素数\n// temp: 当前因子数量为 num的时候的数值\n// num: 当前因子数\n// up：上一个素数的幂，这次应该小于等于这个幂次嘛\nvoid dfs(unsigned long long depth, unsigned long long temp,\n         unsigned long long num, unsigned long long up) &#123;\n  if (num &gt; n || depth &gt;= 16) return;  // 边界条件\n  if (num == n &amp;&amp; ans &gt; temp) &#123;        // 取最小的ans\n    ans = temp;\n    return;\n  &#125;\n  for (int i = 1; i &lt;= up; i++) &#123;\n    if (temp * p[depth] &gt; ans)\n      break;  // 剪枝：如果加一个这个乘数的结果比ans要大，则必不是最佳方案\n    dfs(depth + 1, temp = temp * p[depth], num * (i + 1),\n        i);  // 取一个该乘数，进行对下一个乘数的搜索\n  &#125;\n&#125;\n\nint main() &#123;\n  scanf(&quot;%llu&quot;, &amp;n);\n  ans = ~(unsigned long long)0;\n  dfs(0, 1, 1, 64);\n  printf(&quot;%llu\\n&quot;, ans);\n  return 0;\n&#125;\n</code></pre>\n<p>dfs 神！</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305093108941.png\" alt=\"image-20240305093108941\" /></p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n\nint p[16] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53&#125;;\nunsigned long long n;\nunsigned long long ans,\n    ans_num;  // ans 为 n 以内的最大反素数（会持续更新），ans_sum 为\n              // ans的因子数。\n\n// depth: 当前在枚举第几个素数\n// temp: 当前因子数量为 num的时候的数值\n// num: 当前因子数\n// up：上一个素数的幂，这次应该小于等于这个幂次嘛\nvoid dfs(int depth, unsigned long long temp, unsigned long long num, int up) &#123;\n  if (depth &gt;= 16 || temp &gt; n) return;\n  if (num &gt; ans_num) &#123;  // 更新答案\n    ans = temp;\n    ans_num = num;\n  &#125;\n  if (num == ans_num &amp;&amp; ans &gt; temp) ans = temp;  // 更新答案\n  for (int i = 1; i &lt;= up; i++) &#123;\n    if (temp * p[depth] &gt; n)\n      break;  // 剪枝：如果加一个这个乘数的结果比ans要大，则必不是最佳方案\n    dfs(depth + 1, temp *= p[depth], num * (i + 1),\n        i);  // 取一个该乘数，进行对下一个乘数的搜索\n  &#125;\n  return;\n&#125;\n\nint main() &#123;\n  while (scanf(&quot;%llu&quot;, &amp;n) != EOF) &#123;\n    ans_num = 0;\n    dfs(0, 1, 1, 60);\n    printf(&quot;%llu\\n&quot;, ans);\n  &#125;\n  return 0;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305093256296.png\" alt=\"image-20240305093256296\" /></p>\n<p>gcd(a,b)=gcd(b,a mod b)</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305093448183.png\" alt=\"image-20240305093448183\" /></p>\n<pre><code>// Version 1\nint gcd(int a, int b) &#123;\n  if (b == 0) return a;\n  return gcd(b, a % b);\n&#125;\n\n// Version 2\nint gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;\n</code></pre>\n<pre><code>int gcd(int a, int b) &#123;\n  while (b != 0) &#123;\n    int tmp = a;\n    a = b;\n    b = tmp % b;\n  &#125;\n  return a;\n&#125;\n</code></pre>\n<pre><code>def gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n</code></pre>\n<pre><code>def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n</code></pre>\n<p>另外，对于 C<ins>14，我们可以使用自带的  <code>__gcd(a,b)</code>  函数来求最大公约数。而对于 C</ins> 17，我们可以使用 <a href=\"https://en.cppreference.com/w/cpp/header/numeric\">``</a> 头中的 <a href=\"https://en.cppreference.com/w/cpp/numeric/gcd\"> <code>std::gcd</code> </a> 与 <a href=\"https://en.cppreference.com/w/cpp/numeric/lcm\"> <code>std::lcm</code> </a> 来求最大公约数和最小公倍数。</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305095100433.png\" alt=\"image-20240305095100433\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305095146169.png\" alt=\"image-20240305095146169\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305095941238.png\" alt=\"image-20240305095941238\" /></p>\n<pre><code>Big gcd(Big a, Big b) &#123;\n  // 记录a和b的公因数2出现次数\n  int atimes = 0, btimes = 0;\n  while (a % 2 == 0) &#123;\n    a &gt;&gt;= 1;\n    atimes++;\n  &#125;\n  while (b % 2 == 0) &#123;\n    b &gt;&gt;= 1;\n    btimes++;\n  &#125;\n  for (;;) &#123;\n    // a和b公因数中的2已经计算过了，后面不可能出现a,b均为偶数的情况\n    while (a % 2 == 0) &#123;\n      a &gt;&gt;= 1;\n    &#125;\n    while (b % 2 == 0) &#123;\n      b &gt;&gt;= 1;\n    &#125;\n    if (a == b) break;\n    // 确保 a&gt;=b\n    if (a &lt; b) swap(a, b);\n    a -= b;\n  &#125;\n  return a &lt;&lt; min(atimes, btimes);\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305100854375.png\" alt=\"image-20240305100854375\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305100917948.png\" alt=\"image-20240305100917948\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305101025113.png\" alt=\"image-20240305101025113\" /></p>\n<pre><code>int gcd(int a, int b, int&amp; x, int&amp; y) &#123;\n  x = 1, y = 0;\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\n  while (b1) &#123;\n    int q = a1 / b1;\n    tie(x, x1) = make_tuple(x1, x - q * x1);\n    tie(y, y1) = make_tuple(y1, y - q * y1);\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\n  &#125;\n  return a1;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102040888.png\" alt=\"image-20240305102040888\" /></p>\n<p>线性代数 yyds</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102254449.png\" alt=\"image-20240305102254449\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102303903.png\" alt=\"image-20240305102303903\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102312659.png\" alt=\"image-20240305102312659\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102631758.png\" alt=\"image-20240305102631758\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102721727.png\" alt=\"image-20240305102721727\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305102823965.png\" alt=\"image-20240305102823965\" /></p>\n<pre><code>long long H(int n) &#123;\n  long long res = 0;  // 储存结果\n  int l = 1, r;       // 块左端点与右端点\n  while (l &lt;= n) &#123;\n    r = n / (n / l);  // 计算当前块的右端点\n    res += (r - l + 1) * 1LL *\n           (n / l);  // 累加这一块的贡献到结果中。乘上 1LL 防止溢出\n    l = r + 1;  // 左端点移到下一块\n  &#125;\n  return res;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305103222715.png\" alt=\"image-20240305103222715\" /></p>\n<ol>\n<li><a href=\"https://www.luogu.com.cn/problem/P2261\">CQOI2007 余数求和</a>（需要一点转化和特判）</li>\n<li><a href=\"https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=27&amp;page=show_problem&amp;problem=2521\">UVa11526 H(n)</a>（几乎可以当做模板题）</li>\n<li><a href=\"https://www.luogu.com.cn/problem/P3455\">POI2007 ZAP-Queries</a>（数论分块一般配合 <a href=\"https://oiwiki.com/math/number-theory/mobius/\">莫比乌斯反演</a> 用以进一步降低复杂度；本题需要用到 <img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305105002108.png\" alt=\"image-20240305105002108\" /></li>\n</ol>\n<p>欧拉函数 表示的是小于等于 n 和互质的数的个数</p>\n<p>当 n 是质数的时候，欧拉函数等于 n-1</p>\n<p>性质</p>\n<ul>\n<li>欧拉函数是积性函数</li>\n<li>gcd (a,b)=1, 则<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo>∗</mo><mi>b</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>a</mi><mo stretchy=\"false\">)</mo><mo>∗</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>b</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\phi(a*b)=\\phi(a)*\\phi(b)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">a</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">)</span></span></span></span></li>\n<li>特别的，当 n 是奇数的时候，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">\\phi(2n)=\\phi(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">ϕ</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></li>\n</ul>\n<pre><code>#include &lt;cmath&gt;\n\nint euler_phi(int n) &#123;\n  int ans = n;\n  for (int i = 2; i * i &lt;= n; i++)\n    if (n % i == 0) &#123;\n      ans = ans / i * (i - 1);\n      while (n % i == 0) n /= i;\n    &#125;\n  if (n &gt; 1) ans = ans / n * (n - 1);\n  return ans;\n&#125;\n</code></pre>\n<p>这种算法的时间复杂度是 O (<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding=\"application/x-tex\">\\sqrt{n}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.04em;vertical-align:-0.2397em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8003em;\"><span class=\"svg-align\" style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord mathnormal\">n</span></span></span><span style=\"top:-2.7603em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.2397em;\"><span></span></span></span></span></span></span></span></span>)</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305110411881.png\" alt=\"image-20240305110411881\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305110620807.png\" alt=\"image-20240305110620807\" /></p>\n<pre><code>ll Pollard_Rho(ll N) &#123;\n  ll c = rand() % (N - 1) + 1;\n  ll t = f(0, c, N);\n  ll r = f(f(0, c, N), c, N);\n  while (t != r) &#123;\n    ll d = gcd(abs(t - r), N);\n    if (d &gt; 1) return d;\n    t = f(t, c, N);\n    r = f(f(r, c, N), c, N);\n  &#125;\n  return N;\n&#125;\n</code></pre>\n<pre><code>ll Pollard_Rho(ll N) &#123;\n  ll c = rand() % (N - 1) + 1;\n  ll t = f(0, c, N);\n  ll r = f(f(0, c, N), c, N);\n  while (t != r) &#123;\n    ll d = gcd(abs(t - r), N);\n    if (d &gt; 1) return d;\n    t = f(t, c, N);\n    r = f(f(r, c, N), c, N);\n  &#125;\n  return N;\n&#125;\n\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305111254401.png\" alt=\"image-20240305111254401\" /></p>\n<p>倍增优化的代码实现</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305111849993.png\" alt=\"image-20240305111849993\" /></p>\n<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long ll;\n\nint t;\nlong long max_factor, n;\n\nlong long gcd(long long a, long long b) &#123;\n  if (b == 0) return a;\n  return gcd(b, a % b);\n&#125;\n\nlong long quick_pow(long long x, long long p, long long mod) &#123;  // 快速幂\n  long long ans = 1;\n  while (p) &#123;\n    if (p &amp; 1) ans = (__int128)ans * x % mod;\n    x = (__int128)x * x % mod;\n    p &gt;&gt;= 1;\n  &#125;\n  return ans;\n&#125;\n\nbool Miller_Rabin(long long p) &#123;  // 判断素数\n  if (p &lt; 2) return 0;\n  if (p == 2) return 1;\n  if (p == 3) return 1;\n  long long d = p - 1, r = 0;\n  while (!(d &amp; 1)) ++r, d &gt;&gt;= 1;  // 将d处理为奇数\n  for (long long k = 0; k &lt; 10; ++k) &#123;\n    long long a = rand() % (p - 2) + 2;\n    long long x = quick_pow(a, d, p);\n    if (x == 1 || x == p - 1) continue;\n    for (int i = 0; i &lt; r - 1; ++i) &#123;\n      x = (__int128)x * x % p;\n      if (x == p - 1) break;\n    &#125;\n    if (x != p - 1) return 0;\n  &#125;\n  return 1;\n&#125;\n\nlong long Pollard_Rho(long long x) &#123;\n  long long s = 0, t = 0;\n  long long c = (long long)rand() % (x - 1) + 1;\n  int step = 0, goal = 1;\n  long long val = 1;\n  for (goal = 1;; goal *= 2, s = t, val = 1) &#123;  // 倍增优化\n    for (step = 1; step &lt;= goal; ++step) &#123;\n      t = ((__int128)t * t + c) % x;\n      val = (__int128)val * abs(t - s) % x;\n      if ((step % 127) == 0) &#123;\n        long long d = gcd(val, x);\n        if (d &gt; 1) return d;\n      &#125;\n    &#125;\n    long long d = gcd(val, x);\n    if (d &gt; 1) return d;\n  &#125;\n&#125;\n\nvoid fac(long long x) &#123;\n  if (x &lt;= max_factor || x &lt; 2) return;\n  if (Miller_Rabin(x)) &#123;              // 如果x为质数\n    max_factor = max(max_factor, x);  // 更新答案\n    return;\n  &#125;\n  long long p = x;\n  while (p &gt;= x) p = Pollard_Rho(x);  // 使用该算法\n  while ((x % p) == 0) x /= p;\n  fac(x), fac(p);  // 继续向下分解x和p\n&#125;\n\nint main() &#123;\n  scanf(&quot;%d&quot;, &amp;t);\n  while (t--) &#123;\n    srand((unsigned)time(NULL));\n    max_factor = 0;\n    scanf(&quot;%lld&quot;, &amp;n);\n    fac(n);\n    if (max_factor == n)  // 最大的质因数即自己\n      printf(&quot;Prime\\n&quot;);\n    else\n      printf(&quot;%lld\\n&quot;, max_factor);\n  &#125;\n  return 0;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121231841.png\" alt=\"image-20240305121231841\" /></p>\n<pre><code>vector&lt;int&gt; prime;\nbool is_prime[N];\n\nvoid Eratosthenes(int n) &#123;\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i &lt;= n; ++i) is_prime[i] = true;\n  for (int i = 2; i &lt;= n; ++i) &#123;\n    if (is_prime[i]) &#123;\n      prime.push_back(i);\n      if ((long long)i * i &gt; n) continue;\n      for (int j = i * i; j &lt;= n; j += i)\n        // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i\n        // 的倍数开始，提高了运行速度\n        is_prime[j] = false;  // 是 i 的倍数的均不是素数\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121344310.png\" alt=\"image-20240305121344310\" /></p>\n<p>筛至平方根提高效率</p>\n<pre><code>vector&lt;int&gt; prime;\nbool is_prime[N];\n\nvoid Eratosthenes(int n) &#123;\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i &lt;= n; ++i) is_prime[i] = true;\n  // i * i &lt;= n 说明 i &lt;= sqrt(n)\n  for (int i = 2; i * i &lt;= n; ++i) &#123;\n    if (is_prime[i])\n      for (int j = i * i; j &lt;= n; j += i) is_prime[j] = false;\n  &#125;\n  for (int i = 2; i &lt;= n; ++i)\n    if (is_prime[i]) prime.push_back(i);\n&#125;\n\n\n\n\n\n\nprime = []\nis_prime = [False] * N\n\ndef Eratosthenes(n):\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, n + 1):\n        is_prime[i] = True\n    # 让 i 循环到 &lt;= sqrt(n)\n    for i in range(2, isqrt(n) + 1): # `isqrt` 是 Python 3.8 新增的函数\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    for i in range(2, n + 1):\n        if is_prime[i]:\n            prime.append(i)\n\n\n</code></pre>\n<p>这种优化不会影响渐进时间复杂度，实际上重复以上证明，我们将得到 <img loading=\"lazy\" data-src=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\" alt=\"n n n qrt n + o(n)\" />，根据对数的性质，它们的渐进相同，但操作次数会明显减少。</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121447195.png\" alt=\"image-20240305121447195\" /></p>\n<pre><code>int count_primes(int n) &#123;\n  const int S = 10000;\n  vector&lt;int&gt; primes;\n  int nsqrt = sqrt(n);\n  vector&lt;char&gt; is_prime(nsqrt + 1, true);\n  for (int i = 2; i &lt;= nsqrt; i++) &#123;\n    if (is_prime[i]) &#123;\n      primes.push_back(i);\n      for (int j = i * i; j &lt;= nsqrt; j += i) is_prime[j] = false;\n    &#125;\n  &#125;\n  int result = 0;\n  vector&lt;char&gt; block(S);\n  for (int k = 0; k * S &lt;= n; k++) &#123;\n    fill(block.begin(), block.end(), true);\n    int start = k * S;\n    for (int p : primes) &#123;\n      int start_idx = (start + p - 1) / p;\n      int j = max(start_idx, p) * p - start;\n      for (; j &lt; S; j += p) block[j] = false;\n    &#125;\n    if (k == 0) block[0] = block[1] = false;\n    for (int i = 0; i &lt; S &amp;&amp; start + i &lt;= n; i++) &#123;\n      if (block[i]) result++;\n    &#125;\n  &#125;\n  return result;\n&#125;\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121508991.png\" alt=\"image-20240305121508991\" /></p>\n<p>卧槽不断优化牛逼</p>\n<pre><code>vector&lt;int&gt; pri;\nbool not_prime[N];\n\nvoid pre(int n) &#123;\n  for (int i = 2; i &lt;= n; ++i) &#123;\n    if (!not_prime[i]) &#123;\n      pri.push_back(i);\n    &#125;\n    for (int pri_j : pri) &#123;\n      if (i * pri_j &gt; n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) &#123;\n        // i % pri_j == 0\n        // 换言之，i 之前被 pri_j 筛过了\n        // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被\n        // pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break\n        // 掉就好了\n        break;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n\npri = []\nnot_prime = [False] * N\n\ndef pre(n):\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n        for pri_j in pri:\n            if i * pri_j &gt; n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                &quot;&quot;&quot;\n                i % pri_j == 0\n                换言之，i 之前被 pri_j 筛过了\n                由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被\n                pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break\n                掉就好了\n                &quot;&quot;&quot;\n                break\n                \n                \n                \n                \n筛法求欧拉函数\nvector&lt;int&gt; pri;\nbool not_prime[N];\nint phi[N];\n\nvoid pre(int n) &#123;\n  phi[1] = 1;\n  for (int i = 2; i &lt;= n; i++) &#123;\n    if (!not_prime[i]) &#123;\n      pri.push_back(i);\n      phi[i] = i - 1;\n    &#125;\n    for (int pri_j : pri) &#123;\n      if (i * pri_j &gt; n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) &#123;\n        phi[i * pri_j] = phi[i] * pri_j;\n        break;\n      &#125;\n      phi[i * pri_j] = phi[i] * phi[pri_j];\n    &#125;\n  &#125;\n&#125;\n\npri = []\nnot_prime = [False] * N\nphi = [0] * N\n\ndef pre(n):\n    phi[1] = 1\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n            phi[i] = i - 1\n        for pri_j in pri:\n            if i * pri_j &gt; n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                phi[i * pri_j] = phi[i] * pri_j\n                break\n            phi[i * pri_j] = phi[i] * phi[pri_j]\n</code></pre>\n<p>筛法求莫比乌斯函数是一种用于计算莫比乌斯函数值的有效方法，它可以在线性时间内计算出一定范围内所有数的莫比乌斯函数值。这种方法通常被称为线性筛法。</p>\n<p>线性筛法的基本思想是利用数论中的一些性质，在遍历过程中逐步计算每个数的莫比乌斯函数值，同时将合数标记出来，以避免重复计算。</p>\n<p>以下是线性筛法求莫比乌斯函数的基本步骤：</p>\n<ol>\n<li>初始化一个数组  <code>mu[]</code> ，用于存储每个数的莫比乌斯函数值，初始值为 1。</li>\n<li>遍历从 2 到 n 的每个数 i，对于每个素数，将其莫比乌斯函数值设置为 -1（因为素数的莫比乌斯函数值为 -1），同时将所有大于 1 的 i 的倍数的莫比乌斯函数值设置为 0。</li>\n<li>对于每个大于 1 的数 i，如果 i 可以被某个素数 p 整除，则将 i 的莫比乌斯函数值设置为 -mu [i/p]，否则设置为 0。</li>\n<li>最后得到的数组  <code>mu[]</code>  中存储了从 1 到 n 的每个数的莫比乌斯函数值。</li>\n</ol>\n<p>下面是用 C++ 实现线性筛法求莫比乌斯函数的示例代码：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; mobius(int n) &#123;\n    vector&lt;int&gt; mu(n + 1, 1);\n    vector&lt;int&gt; prime;\n    vector&lt;bool&gt; is_prime(n + 1, true);\n    mu[1] = 1;\n    for (int i = 2; i &lt;= n; ++i) &#123;\n        if (is_prime[i]) &#123;\n            prime.push_back(i);\n            mu[i] = -1;\n        &#125;\n        for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; ++j) &#123;\n            is_prime[i * prime[j]] = false;\n            if (i % prime[j] == 0) &#123;\n                mu[i * prime[j]] = 0;\n                break;\n            &#125; else &#123;\n                mu[i * prime[j]] = -mu[i];\n            &#125;\n        &#125;\n    &#125;\n    return mu;\n&#125;\n\nint main() &#123;\n    int n = 10;\n    vector&lt;int&gt; mu = mobius(n);\n    for (int i = 1; i &lt;= n; ++i) &#123;\n        cout &lt;&lt; &quot;mu[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; mu[i] &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121752199.png\" alt=\"image-20240305121752199\" /></p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240305121804238.png\" alt=\"image-20240305121804238\" /></p>\n<pre><code>vector&lt;int&gt; pri;\nbool not_prime[N];\nint mu[N];\n\nvoid pre(int n) &#123;\n  mu[1] = 1;\n  for (int i = 2; i &lt;= n; ++i) &#123;\n    if (!not_prime[i]) &#123;\n      mu[i] = -1;\n      pri.push_back(i);\n    &#125;\n    for (int pri_j : pri) &#123;\n      if (i * pri_j &gt; n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) &#123;\n        mu[i * pri_j] = 0;\n        break;\n      &#125;\n      mu[i * pri_j] = -mu[i];\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<pre><code>pri = []\nnot_prime = [False] * N\nmu = [0] * N\n\ndef pre(n):\n    mu[1] = 1\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n            mu[i] = -1\n        for pri_j in pri:\n            if i * pri_j &gt; n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                mu[i * pri_j] = 0\n                break\n            mu[i * pri_j] = -mu[i]\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://lysistic.github.io/2024/03/04/java/",
            "url": "https://lysistic.github.io/2024/03/04/java/",
            "title": "java",
            "date_published": "2024-03-04T00:30:25.000Z",
            "content_html": "<h3 id=\"主函数\"><a class=\"anchor\" href=\"#主函数\">#</a> 主函数</h3>\n<p>Java 类似 C/C++ 语言，需要一个函数（在面向对象中，这被称为方法）作为程序执行的入口点。</p>\n<p>Java 的主函数的格式是固定的，形如：</p>\n<pre><code>class Test &#123;\n    public static void main(String[] args) &#123;\n        // 程序的代码\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"包和导入包\"><a class=\"anchor\" href=\"#包和导入包\">#</a> 包和导入包</h3>\n<p>Java 中的类（ <code>Class</code> ）都被放在一个个包（ <code>package</code> ）里面。在一个包里面不允许有同名的类。在类的第一行通常要说明这个类是属于哪个包的</p>\n<p><code>package org.oi-wiki.tutorial;</code></p>\n<p>包的命名规范一般是： <code>项目所有者的顶级域.项目所有者的二级域.项目名称</code> 。</p>\n<h3 id=\"输入\"><a class=\"anchor\" href=\"#输入\">#</a> 输入</h3>\n<p>可以通过  <code>Scanner</code>  类来处理命令行输入。</p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">package</span> <span class=\"token namespace\">org<span class=\"token punctuation\">.</span>oiwiki<span class=\"token punctuation\">.</span>tutorial</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">import</span> <span class=\"token import\"><span class=\"token namespace\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span></span><span class=\"token class-name\">Scanner</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">Scanner</span> scan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Scanner</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>in<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// System.in 是输入流</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> scan<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token keyword\">double</span> b <span class=\"token operator\">=</span> scan<span class=\"token punctuation\">.</span><span class=\"token function\">nextDouble</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">String</span> c <span class=\"token operator\">=</span> scan<span class=\"token punctuation\">.</span><span class=\"token function\">nextLine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240304083320721.png\" alt=\"image-20240304083320721\" /></p>\n<figure class=\"highlight java\"><figcaption data-lang=\"java\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">class</span> <span class=\"token class-name\">Test</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">char</span> b <span class=\"token operator\">=</span> <span class=\"token char\">'A'</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token keyword\">double</span> s <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello world\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%f\\n\"</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%c\\n\"</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>基于已有的设计创造新的设计，就是面向对象程序设计中的继承。在继承中，新的类不是凭空产生的，而是基于一个已经存在的类而定义出来的。通过继承，新的类自动获得了基础类中所有的成员，包括成员变量和方法，包括各种访问属性的成员，无论是  <code>public</code>  还是  <code>private</code>  。显然，通过继承来定义新的类，远比从头开始写一个新的类要简单快捷和方便。继承是支持代码重用的重要手段之一。</p>\n<p>在 Java 中，继承的关键字为  <code>extends</code> ，且 Java 只支持单继承，但可以实现多接口。</p>\n<p>在 Java 中，所有类都是  <code>Object</code>  类的子类。</p>\n<p>子类继承父类，所有的父类的成员，包括变量和方法，都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>\n<p>每个成员有不同的访问属性，子类继承得到了父类所有的成员，但是不同的访问属性使得子类在使用这些成员时有所不同：有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问。</p>\n<p>下表列出了不同访问属性的父类成员在子类中的访问属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">父类成员访问属性</th>\n<th style=\"text-align:center\">在父类中的含义</th>\n<th style=\"text-align:center\">在子类中的含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>public</code></td>\n<td style=\"text-align:center\">对所有类开放</td>\n<td style=\"text-align:center\">对所有类开放</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>protected</code></td>\n<td style=\"text-align:center\">只有包内其它类、自己和子类可以访问</td>\n<td style=\"text-align:center\">只有包内其它类、自己和子类可以访问</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">缺省（ <code>default</code> ）</td>\n<td style=\"text-align:center\">只有包内其它类可以访问</td>\n<td style=\"text-align:center\">如果子类与父类在同一个包内，只有包内其它类可以访问；否则相当于  <code>private</code> ，不能访问</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>private</code></td>\n<td style=\"text-align:center\">只有自己可以访问</td>\n<td style=\"text-align:center\">不能访问</td>\n</tr>\n</tbody>\n</table>\n<p>在 Java 中当把一个对象赋值给一个变量时，对象的</p>\n<p>如果一个类型实现了接口，也可以称之为该接口的子类型。</p>\n<p>Java 中保存对象类型的变量是多态变量。「多态」这个术语（字面意思是许多形态）是指一个变量可以保存不同类型（即其声明的类型或任何子类型）的对象。</p>\n<p>多态变量：</p>\n<ol>\n<li>Java 的对象变量是多态的，它们能保存不止一种类型的对象。</li>\n<li>它们可以保存的是声明类型的对象，或声明类型子类的对象。</li>\n<li>当把子类的对象赋给父类的变量的时候，就发生了向上转型。</li>\n</ol>\n<p>类型必须与变量的类型相匹配。但由于 Java 有继承的概念，便可重新定义为 <strong>一个变量可以保存其所声明的类型或该类型的任何子类型</strong>。</p>\n<p>泛型指在类定义时不设置类中的属性或方法参数的具体类型，而是在使用（或创建对象）时再进行类型的定义。泛型本质是参数化类型，即所操作的数据类型被指定为一个参数。</p>\n<p>泛型提供了编译时类型安全检测的机制，该机制允许编译时检测非法类型。</p>\n<h2 id=\"接口\"><a class=\"anchor\" href=\"#接口\">#</a> 接口</h2>\n<p>接口（英文：Interface）在 Java 中是一个抽象类型，是抽象方法的集合，通常以  <code>interface</code>  来声明。一个类通过实现接口的方式，从而来继承接口的抽象方法。</p>\n<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>\n<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>\n<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<h2 id=\"lambda-表达式\"><a class=\"anchor\" href=\"#lambda-表达式\">#</a> Lambda 表达式</h2>\n<h3 id=\"简介\"><a class=\"anchor\" href=\"#简介\">#</a> 简介</h3>\n<p>lambda 表达式也可称为闭包，是 Java 8 的最重要的新特性。</p>\n<p>lambda 表达式允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>\n<p>使用 lambda 表达式可以使代码变的更加简洁紧凑。</p>\n<h3 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h3>\n<p><strong>可选类型声明</strong>：不需要声明参数类型，编译器可以统一识别参数值。</p>\n<p><strong>可选的参数圆括号</strong>：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p>\n<p><strong>可选的大括号</strong>：如果主体包含了一个语句，就不需要使用大括号。</p>\n<p><strong>可选的返回关键字</strong>：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</p>\n<p>lambda 表达式声明方式如下：</p>\n<p>以字符串数组按长度排序的自定义比较器为例：</p>\n<pre><code>import java.util.Arrays;\n\npublic class Main &#123;\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) &#123;\n        String[] plants = &#123;&quot;Mercury&quot;, &quot;venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;&#125;;\n        Arrays.sort(plants, (String first, String second) -&gt; (first.length() - second.length()));\n        for (String word : plants) &#123;\n            out.print(word + &quot; &quot;);\n        &#125;\n        out.close();\n    &#125;\n&#125;\n</code></pre>\n<pre><code>import java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main &#123;\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) &#123;\n        String[] plants = &#123;&quot;Mercury&quot;, &quot;venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;&#125;;\n        Arrays.sort(plants, (first, second) -&gt;\n        &#123;\n            // 形参不写类型，可以从上下文判断出\n            int result = first.length() - second.length();\n            return result;\n        &#125;);\n        for (String word : plants) &#123;\n            out.print(word + &quot; &quot;);\n        &#125;\n        out.close();\n    &#125;\n&#125;\n</code></pre>\n<p>在其他情况下，如果编译器无法从上下文中推断出参数的类型，则参数的声明是必要的。这通常发生在以下情况下：</p>\n<ol>\n<li>当参数的类型无法从上下文中推断出时，例如在一个独立的方法体内或 Lambda 表达式的参数不符合期望类型的情况下。</li>\n</ol>\n<pre><code>javaCopy code// Lambda 表达式参数类型的声明是必要的，因为编译器无法从上下文中推断出\nComparator&lt;String&gt; comparator = (String s1, String s2) -&gt; s1.compareTo(s2);\n</code></pre>\n<ol>\n<li>当存在重载的方法时，编译器无法确定应该调用哪个方法，因此需要通过参数的类型来解析调用的方法。</li>\n</ol>\n<pre><code>javaCopy code// 两个重载的方法，编译器需要参数类型来决定调用哪个方法\nvoid foo(int x) &#123; &#125;\nvoid foo(double x) &#123; &#125;\n\n// 调用时需要指定参数类型\nfoo(10);    // 编译错误，无法确定调用哪个重载方法\nfoo(10.0);  // 编译通过，调用 foo(double x)\nfoo((int)10.0); // 编译通过，调用 foo(int x)\n</code></pre>\n<p>总的来说，在大多数情况下，如果编译器能够从上下文中推断出参数的类型，那么参数的声明是可选的。但是，如果编译器无法推断参数的类型，或者存在多个重载的方法，这时候参数的声明就是必要的。</p>\n<ol>\n<li>是一个接口，符合 Java 接口定义。</li>\n<li>只包含一个抽象方法的接口。</li>\n<li>因为只有一个未实现的方法，所以 lambda 表达式可以自动填上去。</li>\n</ol>\n<p>函数式接口使用方式如下： 1. 输出长度为 2 的倍数的字符串。</p>\n<pre><code>import java.io.PrintWriter;\n\npublic class Main &#123;\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) &#123;\n        String[] plants = &#123;&quot;Mercury&quot;, &quot;venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;&#125;;\n        Test test = s -&gt; &#123;  // lambda 表达式作为函数式接口的实例\n            if (s.length() % 2 == 0) &#123;\n                return true;\n            &#125;\n            return false;\n        &#125;;\n        for (String word : plants) &#123;\n            if (test.check(word)) &#123;\n                out.print(word + &quot; &quot;);\n            &#125;\n        &#125;\n        out.close();\n    &#125;\n&#125;\n\ninterface Test &#123;\n    public boolean check(String s);\n&#125;\n</code></pre>\n<p>. 实现加减乘除四则运算。</p>\n<pre><code>import java.io.PrintWriter;\n\npublic class Main &#123;\n    static PrintWriter out = new PrintWriter(System.out);\n\n    public static double calc(double a, double b, Calculator util) &#123;\n        return util.operation(a, b);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Calculator util[] = new Calculator[4];  // 定义函数式接口数组\n        util[0] = (a, b) -&gt; a + b;\n        util[1] = (a, b) -&gt; a - b;\n        util[2] = (a, b) -&gt; a * b;\n        util[3] = (a, b) -&gt; a / b;\n        double a = 20, b = 15;\n        for (Calculator c : util) &#123;\n            System.out.println(calc(a, b, c));\n        &#125;\n        out.close();\n    &#125;\n&#125;\n\ninterface Calculator &#123;\n    public double operation(double a, double b);\n&#125;\n</code></pre>\n<h2 id=\"泛型\"><a class=\"anchor\" href=\"#泛型\">#</a> 泛型</h2>\n<p>泛型指在类定义时不设置类中的属性或方法参数的具体类型，而是在使用（或创建对象）时再进行类型的定义。泛型本质是参数化类型，即所操作的数据类型被指定为一个参数。</p>\n<p>泛型提供了编译时类型安全检测的机制，该机制允许编译时检测非法类型</p>\n",
            "tags": []
        },
        {
            "id": "https://lysistic.github.io/2024/03/03/cpp-O-o/",
            "url": "https://lysistic.github.io/2024/03/03/cpp-O-o/",
            "title": "cpp_O.o",
            "date_published": "2024-03-03T05:05:40.000Z",
            "content_html": "<ul>\n<li>istream // 输入流类型，提供输入操作</li>\n<li>ifstream // 由 istream 派生而来，提供文件读入功能</li>\n<li>ostream // 输出流类型，提供输出操作</li>\n<li>ofstream // 由 ostream 派生而来，提供文件写功能</li>\n<li><code>&gt;&gt; 用于从istream对象读入</code></li>\n<li><code>&lt;&lt; 用于把输出写道ostream</code></li>\n</ul>\n<p>iostream 定义读写控制窗口类型</p>\n<p>fstream 定义读写已命名文件类型</p>\n<p>sstream 所定义的类型读写存储在内存中的 string 对象</p>\n<h1 id=\"智能指针\"><a class=\"anchor\" href=\"#智能指针\">#</a> 智能指针</h1>\n<p>智能指针就是帮我们 C++ 程序员管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而<strong>避免内存泄漏</strong>！</p>\n<p>内存泄漏的例子</p>\n<pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\nusing namespace std;\n// 动态分配内存，没有释放就return\nvoid memoryLeak1() &#123;\n\tstring *str = new string(&quot;动态分配内存！&quot;);\n\treturn;\n&#125;\n// 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了\nint memoryLeak2() &#123;\n\tstring *str = new string(&quot;内存泄露！&quot;);\n\t// ...此处省略一万行代码\n\t// 发生某些异常，需要结束函数\n\tif (1) &#123;\n\t\treturn -1;\n\t&#125;\n\t/\n\t// 另外，使用try、catch结束函数，也会造成内存泄漏！\n\t/\n\n\tdelete str;\t// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放\n\treturn 1;\n&#125;\n\n\nint main(void) &#123;\n\n\tmemoryLeak1();\n\n\tmemoryLeak2();\n\n\treturn 0;\n&#125; \n\n</code></pre>\n<p>使用指针并申请空间，用完没有释放就会造成内存泄漏。</p>\n<p>一个可行的方案：</p>\n<p>动态分配的内存都交由有生命周期的对象来处理，在对象过期时，让他的析构函数删除指向的内存。</p>\n<ol>\n<li>C++98 提供了 auto_ptr 模板的解决方案</li>\n<li>C++11 增加 unique_ptr、shared_ptr 和 weak_ptr</li>\n</ol>\n<h2 id=\"auto_ptr\"><a class=\"anchor\" href=\"#auto_ptr\">#</a> auto_ptr</h2>\n<p>auto_ptr 是 c++ 98 定义的智能指针模板，其定义了管理指针的对象，可以将 new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用 delete 来释放内存</p>\n<p>用法:<br />\n 头文件: #include &lt;memory&gt;<br />\n 用 法: auto_ptr &lt;类型&gt; 变量名 (new 类型)</p>\n<p>例 如:<br />\nauto_ptr&lt;string&gt; str (new string (“我要成为大牛～变得很牛逼！”));<br />\nauto_ptr&lt;vector&lt; int &gt;&gt; av(new vector&lt; int &gt;());<br />\nauto_ptr&lt; int &gt; array(new int[10]);</p>\n<pre><code class=\"language-c++\">#include&lt;mem.h&gt;\n#include&lt;io.h&gt;\n#include&lt;memory&gt;\n#include&lt;iostream&gt;\n#include&lt;stdlib.h&gt;\nusing namespace std;\nclass Test &#123;\npublic:\n\tTest() &#123; cout &lt;&lt; &quot;gouzao&quot; &lt;&lt; endl; &#125;\n\t~Test() &#123; cout &lt;&lt; &quot;xigou...&quot; &lt;&lt; endl; &#125;\n\n\tint getDebug() &#123; return this-&gt;debug; &#125;\n\nprivate:\n\tint debug = 20;\n&#125;;\n\nusing namespace std;\n// 定义智能指针\nint main(void) &#123;\n\n\t//Test *test = new Test;\n\tauto_ptr&lt;Test&gt; test(new Test);\n\n\tcout &lt;&lt; &quot;test-&gt;debug：&quot; &lt;&lt; test-&gt;getDebug() &lt;&lt; endl;\n\tcout &lt;&lt; &quot;(*test).debug：&quot; &lt;&lt; (*test).getDebug() &lt;&lt; endl;\n\n\treturn 0;\n&#125; \n\n</code></pre>\n<p>在程序退出时调用析构函数释放内存</p>\n<p>智能指针常用的三个函数</p>\n<p><strong>get</strong> () 获取智能指针托管的指针地址</p>\n<p><strong>release</strong> () 取消智能指针对动态内存的托管<strong> reset</strong> () 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉</p>\n<p><code>auto_ptr</code>  是 C++11 之前的标准库中的智能指针，它具有独占性质，即不能被多个指针共享。因此，将  <code>auto_ptr</code>  变量定义为全局变量或指针可能会导致一些问题：</p>\n<ol>\n<li><strong>所有权的问题</strong>： <code>auto_ptr</code>  采用了独占所有权的策略，当一个  <code>auto_ptr</code>  对象被赋值给另一个  <code>auto_ptr</code>  对象时，原来的  <code>auto_ptr</code>  对象就失去了对资源的控制权。如果将  <code>auto_ptr</code>  定义为全局变量，那么在程序的不同部分可能会意外地修改或释放全局变量指向的资源，导致不可预测的行为。</li>\n<li><strong>析构顺序问题</strong>：全局变量的析构顺序是未定义的，而  <code>auto_ptr</code>  的析构函数会释放其所管理的资源。如果  <code>auto_ptr</code>  的析构函数被调用时，其他全局变量还在使用这个资源，可能会导致未定义的行为或内存错误。</li>\n<li><strong>线程安全问题</strong>：全局变量的访问可能不是线程安全的，如果多个线程同时访问全局变量，可能会发生竞态条件。而  <code>auto_ptr</code>  的操作并不是线程安全的，因此在多线程环境下，使用全局的  <code>auto_ptr</code>  可能会导致竞态条件，从而导致资源泄漏或内存错误。</li>\n</ol>\n<p>由于上述问题，尽可能不要将  <code>auto_ptr</code>  变量定义为全局变量或指针。相反，应该将  <code>auto_ptr</code>  定义为局部变量，以便在离开作用域时自动释放资源，并避免共享资源的所有权。在 C++11 之后，推荐使用更安全的智能指针，如  <code>unique_ptr</code>  或  <code>shared_ptr</code> 。</p>\n<p>除非自己知道后果，不要把 auto_ptr 智能指针赋值给同类型的另外一个 智能指针</p>\n<p>正是的。 <code>auto_ptr</code>  是一种具有独占所有权的智能指针，它的特性决定了它只能被移动，而不能被复制。当你将一个  <code>auto_ptr</code>  赋值给另一个  <code>auto_ptr</code>  时，所有权会从一个指针转移到另一个指针，原始指针会失去所有权。</p>\n<p>这种转移所有权的行为可能导致一些潜在的问题，尤其是在程序的不同部分使用了同一个资源时。具体来说，可能会出现以下问题：</p>\n<ol>\n<li><strong>悬空指针（Dangling Pointer）</strong>：如果不小心将一个  <code>auto_ptr</code>  赋值给另一个  <code>auto_ptr</code> ，并且原始指针在后续的使用中还会被访问，那么就可能出现悬空指针的问题，即指向已经释放的内存的指针。</li>\n<li><strong>资源泄漏（Resource Leak）</strong>：如果不正确地管理  <code>auto_ptr</code> ，可能会导致资源泄漏。例如，在将  <code>auto_ptr</code>  赋值给另一个  <code>auto_ptr</code>  之后，原始指针没有被释放，导致资源无法释放。</li>\n<li><strong>不确定的行为（Undefined Behavior）</strong>：由于  <code>auto_ptr</code>  的独占性质，可能会导致在不同的地方意外地释放资源或者使用已经释放的资源，从而导致不确定的行为。</li>\n</ol>\n<p>因此，除非你清楚地了解后果并能够确保安全使用，否则不要将  <code>auto_ptr</code>  智能指针赋值给同类型的另一个智能指针。在现代 C++ 中，推荐使用更安全的智能指针，如  <code>unique_ptr</code>  或  <code>shared_ptr</code> ，它们提供了更严格的所有权控制，并且避免了  <code>auto_ptr</code>  可能带来的问题</p>\n<p>C<ins>11 后 auto_ptr 已经被 “抛弃”，已使用 unique_ptr 替代！C</ins>11 后不建议使用 auto_ptr</p>\n<h3 id=\"auto_ptr-被c11抛弃的主要原因\"><a class=\"anchor\" href=\"#auto_ptr-被c11抛弃的主要原因\">#</a> <strong>auto_ptr 被 C++11 抛弃的主要原因</strong></h3>\n<p>复制或者赋值都会改变资源的所有权</p>\n<p>在 STL 容器中使用 auto_ptr 存在着重大风险，因为容器内的元素必须支持可复制和可赋值</p>\n<p>在 C++ 中，左值（lvalue）和右值（rvalue）是用于描述表达式的术语。</p>\n<ul>\n<li>\n<p><strong>左值（lvalue）</strong>：左值是指可以被赋值的表达式，通常是可以取地址的表达式。具体来说，左值是一个具有标识符（即有名称）并且可以通过地址获取其值的表达式。例如，变量、数组元素、函数返回的引用等都是左值。例如：</p>\n<pre><code>cppCopy codeint x = 5; // x是左值\nint arr[5]; // arr是左值\nint&amp; ref = x; // ref是左值\n</code></pre>\n</li>\n<li>\n<p><strong>右值（rvalue）</strong>：右值是指不能被赋值的表达式，通常是临时的、一次性的值。右值没有名称，通常在表达式求值后就消失了。例如，常量、临时对象、函数返回的非引用值等都是右值。例如：</p>\n<pre><code>cppCopy code5 + 3; // 5 + 3是右值\nint* ptr = new int(10); // new int(10)返回的是右值\n</code></pre>\n</li>\n</ul>\n<p>在 C++11 中引入了右值引用（rvalue references），它允许我们更方便地处理右值，并且可以实现移动语义，提高程序的性能。右值引用使用  <code>&amp;&amp;</code>  来声明，例如：</p>\n<pre><code>cppCopy code\nint&amp;&amp; rv = 5; // rv是右值引用\n</code></pre>\n<p>在 C++ 中，直接将右值绑定到左值引用是不允许的。因为左值引用是用于引用左值的，而右值是临时的、一次性的值，不具备地址，无法通过引用来访问。试图将右值直接绑定到左值引用会导致编译错误。</p>\n<p>例如，以下代码会导致编译错误：</p>\n<pre><code>cppCopy code\nint&amp; rv = 5; // 错误：无法将右值绑定到左值引用\n</code></pre>\n<p>正确的做法是使用右值引用来绑定右值：</p>\n<pre><code>cppCopy code\nint&amp;&amp; rv = 5; // 正确：使用右值引用绑定右值\n</code></pre>\n<p>或者，你可以使用  <code>const</code>  修饰左值引用，这样就可以将右值绑定到  <code>const</code>  左值引用：</p>\n<pre><code>cppCopy code\nconst int&amp; rv = 5; // 正确：使用const左值引用绑定右值\n</code></pre>\n<p>这样做是合法的，因为  <code>const</code>  左值引用可以延长右值的生命周期，使其与引用的生命周期相匹配。</p>\n<p>不支持对象数组的内存管理</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Test &#123;\npublic:\n\tTest() &#123; cout &lt;&lt; &quot;Test的构造函数...&quot; &lt;&lt; endl; &#125;\n\t~Test() &#123; cout &lt;&lt; &quot;Test的析构函数...&quot; &lt;&lt; endl; &#125;\n\n\tint getDebug() &#123; return this-&gt;debug; &#125;\n\nprivate:\n\tint debug = 20;\n&#125;;\n\n// 不要定义为全局变量，没有意义\n//auto_ptr&lt;Test&gt; test(new Test);\n\nvoid memoryLeak1() &#123;\n\t//Test *test = new Test;\n\n\t// 定义智能指针\n\tauto_ptr&lt;Test&gt; test(new Test);\n\t\n\tcout &lt;&lt; &quot;test-&gt;debug：&quot; &lt;&lt; test-&gt;getDebug() &lt;&lt; endl;\n\tcout &lt;&lt; &quot;(*test).debug：&quot; &lt;&lt; (*test).getDebug() &lt;&lt; endl;\n\n\n\t// get方法\n\tTest *tmp = test.get();\t\t// 获取指针返回\n\tcout &lt;&lt; &quot;tmp-&gt;debug：&quot; &lt;&lt; tmp-&gt;getDebug() &lt;&lt; endl;\n\n\n\t// release方法\n\tTest *tmp2 = test.release();\t// 取消智能指针对动态内存的托管\n\tdelete tmp2;\t// 之前分配的内存需要自己手动释放\n\n\n\t// reset方法：重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉\n\ttest.reset();\t\t\t// 释放掉智能指针托管的指针内存，并将其置NULL\n\ttest.reset(new Test());\t// 释放掉智能指针托管的指针内存，并将参数指针取代之\n\n\n\t// 忠告：不要将智能指针定义为指针\n\t//auto_ptr&lt;Test&gt; *tp = new auto_ptr&lt;Test&gt;(new Test);\n\n\t// 忠告：不要定义指向智能指针对象的指针变量\n\t//auto_ptr&lt;Test&gt; t1(new Test);\n\t//auto_ptr&lt;Test&gt; t2(new Test);\n\t//t1 = t2;\n\n\treturn;\n&#125;\n\nint memoryLeak2() &#123;\n\t//Test *test = new Test();\n\n\t// 定义智能指针\n\tauto_ptr&lt;Test&gt; test(new Test);\n\n\t// ...此处省略一万行代码\n\n\t// 发生某些异常，需要结束函数\n\tif (1) &#123;\n\t\treturn -1;\n\t&#125;\n\n\t//delete test;\n\treturn 1;\n&#125;\n\n\nint main1(void) &#123;\n\n\t//memoryLeak1();\n\n\t//memoryLeak2();\n\n\t//Test *test = new Test;\n\t//auto_ptr&lt;Test&gt; test(new Test);\n\n\t//cout &lt;&lt; &quot;test-&gt;debug：&quot; &lt;&lt; test-&gt;getDebug() &lt;&lt; endl;\n\t//cout &lt;&lt; &quot;(*test).debug：&quot; &lt;&lt; (*test).getDebug() &lt;&lt; endl;\n\n\n\t auto_ptr 被C++11抛弃的主要原因\n\t//auto_ptr&lt;string&gt; p1(new string(&quot;I'm Li Ming!&quot;));\n\t//auto_ptr&lt;string&gt; p2(new string(&quot;I'm age 22.&quot;));\n\t//\n\t//cout &lt;&lt; &quot;p1：&quot; &lt;&lt; p1.get() &lt;&lt; endl;\n\t//cout &lt;&lt; &quot;p2：&quot; &lt;&lt; p2.get() &lt;&lt; endl;\n\n\t//p1 = p2;\n\t//cout &lt;&lt; &quot;p1 = p2 赋值后：&quot; &lt;&lt; endl;\n\t//cout &lt;&lt; &quot;p1：&quot; &lt;&lt; p1.get() &lt;&lt; endl;\n\t//cout &lt;&lt; &quot;p2：&quot; &lt;&lt; p2.get() &lt;&lt; endl;\n\n\n\n\t// 弊端2.在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制\n\tvector&lt;auto_ptr&lt;string&gt;&gt; vec;\n\tauto_ptr&lt;string&gt; p3(new string(&quot;I'm P3&quot;));\n\tauto_ptr&lt;string&gt; p4(new string(&quot;I'm P4&quot;));\n\n\tvec.push_back(std::move(p3));\n\tvec.push_back(std::move(p4));\n\n\tcout &lt;&lt; &quot;vec.at(0)：&quot; &lt;&lt;  *vec.at(0) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;vec[1]：&quot; &lt;&lt;  *vec[1] &lt;&lt; endl;\n\n\n\t// 风险来了：\n\tvec[0] = vec[1];\n\tcout &lt;&lt; &quot;vec.at(0)：&quot; &lt;&lt; *vec.at(0) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;vec[1]：&quot; &lt;&lt; *vec[1] &lt;&lt; endl;\n\n\n\t// 弊端3.不支持对象数组的内存管理\n\t//auto_ptr&lt;int[]&gt; array(new int[5]);\t// 不能这样定义\n\treturn 0;\n&#125; \n\n\n</code></pre>\n<p>三、unique_ptr<br />\nauto_ptr 是用于 C++11 之前的智能指针。由于 auto_ptr 基于排他所有权模式：两个指针不能指向同一个资源，复制或赋值都会改变资源的所有权。auto_ptr 主要有三大问题：</p>\n<p>复制和赋值会改变资源的所有权，不符合人的直觉。<br />\n在 STL 容器中使用 auto_ptr 存在重大风险，因为容器内的元素必需支持可复制（copy constructable）和可赋值（assignable）。<br />\n不支持对象数组的操作</p>\n<ol>\n<li><strong>所有权语义</strong>：\n<ul>\n<li><code>auto_ptr</code>  使用独占所有权语义，即一个  <code>auto_ptr</code>  指针拥有对其所管理资源的唯一所有权。这意味着一个  <code>auto_ptr</code>  对象的所有权可以从一个对象转移到另一个对象，但不能共享资源。</li>\n<li><code>unique_ptr</code>  也使用独占所有权语义，但它提供了更严格的所有权管理。例如， <code>unique_ptr</code>  的拷贝构造函数和赋值操作符都被删除了，因此不能像  <code>auto_ptr</code>  那样直接赋值或拷贝。相反， <code>unique_ptr</code>  只能通过移动来转移所有权。</li>\n</ul>\n</li>\n<li><strong>删除拷贝构造函数和赋值操作符</strong>：\n<ul>\n<li>在  <code>unique_ptr</code>  中，拷贝构造函数和赋值操作符被显式地删除了，这意味着  <code>unique_ptr</code>  不能进行拷贝或赋值操作，只能通过移动语义来转移资源的所有权。</li>\n<li><code>auto_ptr</code>  允许拷贝和赋值，但它的拷贝语义并不安全，可能会导致悬空指针问题。</li>\n</ul>\n</li>\n<li><strong>自定义删除器</strong>：\n<ul>\n<li><code>unique_ptr</code>  允许你指定一个自定义删除器，用于释放资源时的操作。这使得  <code>unique_ptr</code>  可以管理动态分配的数组以及其他需要特殊处理的资源。</li>\n<li><code>auto_ptr</code>  没有提供类似的功能，它只能用于管理单个动态分配的对象。</li>\n</ul>\n</li>\n</ol>\n<p>综上所述，虽然  <code>unique_ptr</code>  和  <code>auto_ptr</code>  在某些方面类似，但由于  <code>unique_ptr</code>  提供了更严格的所有权管理和更安全的拷贝语义，因此在 C++11 中推荐使用  <code>unique_ptr</code> ，而不是  <code>auto_ptr</code> 。</p>\n<pre><code>unique_ptr&lt;string&gt; p1(new string(&quot;I'm Li Ming!&quot;));\nunique_ptr&lt;string&gt; p2(new string(&quot;I'm age 22.&quot;));\n\t\ncout &lt;&lt; &quot;p1：&quot; &lt;&lt; p1.get() &lt;&lt; endl;\ncout &lt;&lt; &quot;p2：&quot; &lt;&lt; p2.get() &lt;&lt; endl;\n\np1 = p2;\t\t\t\t\t// 禁止左值赋值\nunique_ptr&lt;string&gt; p3(p2);\t// 禁止左值赋值构造\n\nunique_ptr&lt;string&gt; p3(std::move(p1));\np1 = std::move(p2);\t// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样\n\ncout &lt;&lt; &quot;p1 = p2 赋值后：&quot; &lt;&lt; endl;\ncout &lt;&lt; &quot;p1：&quot; &lt;&lt; p1.get() &lt;&lt; endl;\ncout &lt;&lt; &quot;p2：&quot; &lt;&lt; p2.get() &lt;&lt; endl;\n\n</code></pre>\n<p>参考图片</p>\n<p><img loading=\"lazy\" data-src=\"C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240303154043937.png\" alt=\"image-20240303154043937\" /></p>\n<p><strong>B</strong>. 在 STL 容器中使用 unique_ptr，不允许直接赋值</p>\n<pre><code>vector&lt;unique_ptr&lt;string&gt;&gt; vec;\nunique_ptr&lt;string&gt; p3(new string(&quot;I'm P3&quot;));\nunique_ptr&lt;string&gt; p4(new string(&quot;I'm P4&quot;));\n\nvec.push_back(std::move(p3));\nvec.push_back(std::move(p4));\n\ncout &lt;&lt; &quot;vec.at(0)：&quot; &lt;&lt; *vec.at(0) &lt;&lt; endl;\ncout &lt;&lt; &quot;vec[1]：&quot; &lt;&lt; *vec[1] &lt;&lt; endl;\n\nvec[0] = vec[1];\t/* 不允许直接赋值 */\nvec[0] = std::move(vec[1]);\t\t// 需要使用move修饰，使得程序员知道后果\n\ncout &lt;&lt; &quot;vec.at(0)：&quot; &lt;&lt; *vec.at(0) &lt;&lt; endl;\ncout &lt;&lt; &quot;vec[1]：&quot; &lt;&lt; *vec[1] &lt;&lt; endl;\n\n\n</code></pre>\n<p>在 C++ 中， <code>std::move</code>  是一个函数模板，它用于将一个左值转换为右值引用，以便进行移动语义的操作。它并不执行移动操作，而只是告诉编译器你有意进行移动操作。</p>\n<p><code>std::move</code>  的作用主要有两个方面：</p>\n<ol>\n<li><strong>标记对象为右值</strong>：使用  <code>std::move</code>  可以将一个左值转换为右值引用，告诉编译器你有意将其移动，而不是复制。这在实现移动语义时非常有用，因为移动语义通常比复制语义更高效。例如，当你将一个对象传递给接受右值引用的函数时，你可以使用  <code>std::move</code>  来传递对象的所有权，以便进行移动构造或移动赋值。</li>\n<li><strong>避免不必要的拷贝</strong>：在某些情况下，对象的拷贝操作可能是不必要的，因为你知道这个对象在后续的使用中不再需要了。使用  <code>std::move</code>  可以避免不必要的拷贝，从而提高程序的性能。例如，在将一个对象放入容器中时，你可以使用  <code>std::move</code>  来移动对象，而不是复制对象。</li>\n</ol>\n<p>综上所述， <code>std::move</code>  的主要作用是将左值转换为右值引用，以便进行移动语义的操作，并且可以避免不必要的拷贝，提高程序的性能。但需要注意的是，使用  <code>std::move</code>  后，原始对象的状态会变为不确定的，因此在移动后，不要再对原始对象进行操作。</p>\n<p>除了上面 ABC 三项外，unique_ptr 的其余用法都与 auto_ptr 用法一致。</p>\n<pre><code>构造\nclass Test &#123;\npublic:\n\tTest() &#123; cout &lt;&lt; &quot;Test的构造函数...&quot; &lt;&lt; endl; &#125;\n\t~Test() &#123; cout &lt;&lt; &quot;Test的析构函数...&quot; &lt;&lt; endl; &#125;\n\n\tvoid doSomething() &#123; cout &lt;&lt; &quot;do something......&quot; &lt;&lt; endl; &#125;\n&#125;;\n\n\n// 自定义一个内存释放其\nclass DestructTest &#123;\n\tpublic:\n\tvoid operator()(Test *pt) &#123;\n\t\tpt-&gt;doSomething();\n\t\tdelete pt;\n\t&#125;\n&#125;;\n\n// unique_ptr&lt;T&gt; up; 空的unique_ptr，可以指向类型为T的对象\nunique_ptr&lt;Test&gt; t1;\n\n// unique_ptr&lt;T&gt; up1(new T());\t定义unique_ptr,同时指向类型为T的对象\nunique_ptr&lt;Test&gt; t2(new Test);\n\n// unique_ptr&lt;T[]&gt; up;\t空的unique_ptr，可以指向类型为T[的数组对象\nunique_ptr&lt;int[]&gt; t3;\n\n// unique_ptr&lt;T[]&gt; up1(new T[]);\t定义unique_ptr,同时指向类型为T的数组对象\nunique_ptr&lt;int[]&gt; t4(new int[5]);\n\n// unique_ptr&lt;T, D&gt; up();\t空的unique_ptr，接受一个D类型的删除器D，使用D释放内存\nunique_ptr&lt;Test, DestructTest&gt; t5;\n\n// unique_ptr&lt;T, D&gt; up(new T());\t定义unique_ptr,同时指向类型为T的对象，接受一个D类型的删除器D，使用删除器D来释放内存\nunique_ptr&lt;Test, DestructTest&gt; t6(new Test);\n\n\n赋值\nunique_ptr&lt;Test&gt; t7(new Test);\nunique_ptr&lt;Test&gt; t8(new Test);\nt7 = std::move(t8);\t// 必须使用移动语义，结果，t7的内存释放，t8的内存交给t7管理\nt7-&gt;doSomething();\n\n\n主动释放对象\nunique_ptr&lt;Test&gt; t9(new Test);\nt9 = NULL;\nt9 = nullptr;\nt9.reset();\n\n放弃对象的控制权\n\nTest *t10 = t9.release();\n重置\nt9.reset(new Test);\n\n\nauto_ptr 与 unique_ptr智能指针的内存管理陷阱\nauto_ptr&lt;string&gt; p1;\nstring *str = new string(&quot;智能指针的内存管理陷阱&quot;);\np1.reset(str);\t// p1托管str指针\n&#123;\n\tauto_ptr&lt;string&gt; p2;\n\tp2.reset(str);\t// p2接管str指针时，会先取消p1的托管，然后再对str的托管\n&#125;\n\n// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！\ncout &lt;&lt; &quot;str：&quot; &lt;&lt; *p1 &lt;&lt; endl;\n\n</code></pre>\n<p><img loading=\"lazy\" data-src=\"https://img-blog.csdnimg.cn/6b0a0e1ec3984107a1787671c7cad0fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>这是由于 auto_ptr 与 unique_ptr 的排他性所导致的！<br />\n<strong>为了解决这样的问题，我们可以使用 shared_ptr 指针指针</strong></p>\n<p><code>std::shared_ptr</code>  是 C++ 标准库中的智能指针，用于管理动态分配的资源，并提供了共享所有权的语义。它允许多个智能指针共享同一个对象，而不会造成资源重复释放或悬空指针的问题。</p>\n<p><code>std::shared_ptr</code>  的主要特点包括：</p>\n<ol>\n<li><strong>共享所有权</strong>：多个  <code>std::shared_ptr</code>  对象可以指向同一个动态分配的对象，它们共享对该对象的所有权。只有当所有  <code>std::shared_ptr</code>  对象都释放了对该对象的所有权后，该对象才会被销毁。</li>\n<li><strong>引用计数</strong>： <code>std::shared_ptr</code>  内部维护了一个引用计数，用于记录有多少个  <code>std::shared_ptr</code>  对象共享同一个动态分配的对象。每次创建、拷贝、移动或销毁  <code>std::shared_ptr</code>  对象时，引用计数都会相应地增加、减少或清零。</li>\n<li><strong>自动释放资源</strong>：当引用计数减少到零时， <code>std::shared_ptr</code>  会自动释放所管理的资源，即调用动态分配对象的析构函数，并释放对象所占用的内存。</li>\n<li><strong>线程安全的引用计数</strong>： <code>std::shared_ptr</code>  内部的引用计数是线程安全的，因此多个线程可以安全地共享同一个  <code>std::shared_ptr</code>  对象。</li>\n<li><strong>循环引用问题</strong>： <code>std::shared_ptr</code>  的共享所有权特性可能导致循环引用问题，即两个或多个对象相互持有对方的  <code>std::shared_ptr</code>  对象，导致资源永远无法释放。为了避免这种情况，可以使用  <code>std::weak_ptr</code>  来解决循环引用问题。</li>\n</ol>\n<p>总的来说， <code>std::shared_ptr</code>  是一种非常灵活和安全的智能指针，适用于多个对象需要共享同一个资源的情况。它提供了自动释放资源、引用计数、线程安全等特性，能够有效地管理动态分配的资源，并避免内存泄漏和悬空指针问题。</p>\n<pre><code>\nclass Person &#123;\npublic:\n\tPerson(int v) &#123;\n\t\tthis-&gt;no = v;\n\t\tcout &lt;&lt; &quot;构造函数 \\t no = &quot; &lt;&lt; this-&gt;no &lt;&lt; endl;\n\t&#125;\n\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数 \\t no = &quot; &lt;&lt; this-&gt;no &lt;&lt; endl;\n\t&#125;\n\nprivate:\n\tint no;\n&#125;;\n\n// 仿函数，内存删除\nclass DestructPerson &#123;\npublic:\n\tvoid operator() (Person *pt) &#123;\n\t\tcout &lt;&lt; &quot;DestructPerson...&quot; &lt;&lt; endl;\n\t\tdelete pt;\n\t&#125;\n&#125;;\n\n\n引用计数的使用\n\n调用use_count函数可以获得当前托管指针的引用计数。\n\nshared_ptr&lt;Person&gt; sp1;\n\nshared_ptr&lt;Person&gt; sp2(new Person(2));\n\n// 获取智能指针管控的共享指针的数量\tuse_count()：引用计数\ncout &lt;&lt; &quot;sp1\tuse_count() = &quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;\ncout &lt;&lt; &quot;sp2\tuse_count() = &quot; &lt;&lt; sp2.use_count() &lt;&lt; endl &lt;&lt; endl;\n\n// 共享\nsp1 = sp2;\n\ncout &lt;&lt; &quot;sp1\tuse_count() = &quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;\ncout &lt;&lt; &quot;sp2\tuse_count() = &quot; &lt;&lt; sp2.use_count() &lt;&lt; endl &lt;&lt; endl;\n\nshared_ptr&lt;Person&gt; sp3(sp1);\ncout &lt;&lt; &quot;sp1\tuse_count() = &quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;\ncout &lt;&lt; &quot;sp2\tuse_count() = &quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;\ncout &lt;&lt; &quot;sp2\tuse_count() = &quot; &lt;&lt; sp3.use_count() &lt;&lt; endl &lt;&lt; endl;\n\n\n如上代码，sp1 = sp2; 和 shared_ptr&lt; Person &gt; sp3(sp1);就是在使用引用计数了。\n\nsp1 = sp2; --&gt; sp1和sp2共同托管同一个指针，所以他们的引用计数为2；\nshared_ptr&lt; Person &gt; sp3(sp1); --&gt; sp1和sp2和sp3共同托管同一个指针，所以他们的引用计数为3；\n构造\n shared_ptr&lt; T &gt; sp1; 空的shared_ptr，可以指向类型为T的对象\nshared_ptr&lt;Person&gt; sp1;\nPerson *person1 = new Person(1);\nsp1.reset(person1);\t// 托管person1\n\n shared_ptr&lt; T &gt; sp2(new T()); 定义shared_ptr,同时指向类型为T的对象\n shared_ptr&lt;Person&gt; sp2(new Person(2));\nshared_ptr&lt;Person&gt; sp3(sp1);\n\nshared_ptr&lt;T[]&gt; sp4; 空的shared_ptr，可以指向类型为T[]的数组对象 C++17后支持\nshared_ptr&lt;Person[]&gt; sp4;\n\n\nshared_ptr&lt;T[]&gt; sp5(new T[] &#123; … &#125;); 指向类型为T的数组对象 C++17后支持\nshared_ptr&lt;Person[]&gt; sp5(new Person[5] &#123; 3, 4, 5, 6, 7 &#125;);\n\n\n\n shared_ptr&lt; T &gt; sp6(NULL, D()); //空的shared_ptr，接受一个D类型的删除器，使用D释放内存\n shared_ptr&lt;Person&gt; sp6(NULL, DestructPerson());\n\n. shared_ptr&lt; T &gt; sp7(new T(), D()); //定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存\nshared_ptr&lt;Person&gt; sp7(new Person(8), DestructPerson());\n\n\n\n                            \nhttps://blog.csdn.net/cpp_learner/article/details/118912592\n</code></pre>\n<h4 id=\"初始化\"><a class=\"anchor\" href=\"#初始化\">#</a> 初始化</h4>\n<ul>\n<li>\n<p><strong>1).</strong> 方式一：构造函数</p>\n<pre><code>shared_ptr&lt;int&gt; up1(new int(10));  // int(10) 的引用计数为1\nshared_ptr&lt;int&gt; up2(up1);  // 使用智能指针up1构造up2, 此时int(10) 引用计数为2\n\n</code></pre>\n</li>\n<li>\n<p>方式二：使用 make_shared 初始化对象，分配内存效率更高 (推荐使用)<br />\n make_shared 函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr; 用法：<br />\nmake_shared &lt;类型&gt;(构造类型对象需要的参数列表);</p>\n<pre><code>shared_ptr&lt;int&gt; up3 = make_shared&lt;int&gt;(2); // 多个参数以逗号','隔开，最多接受十个\nshared_ptr&lt;string&gt; up4 = make_shared&lt;string&gt;(&quot;字符串&quot;);\nshared_ptr&lt;Person&gt; up5 = make_shared&lt;Person&gt;(9);\n\n</code></pre>\n</li>\n</ul>\n<p>4 赋值</p>\n<pre><code>shared_ptrr&lt;int&gt; up1(new int(10));  // int(10) 的引用计数为1\nshared_ptr&lt;int&gt; up2(new int(11));   // int(11) 的引用计数为1\nup1 = up2;\t// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2\n\n</code></pre>\n<p><strong>主动释放对象</strong></p>\n<pre><code>shared_ptrr&lt;int&gt; up1(new int(10));\nup1 = nullptr ;\t// int(10) 的引用计数减1,计数归零内存释放 \n// 或\nup1 = NULL; // 作用同上 \n\n</code></pre>\n<p><strong>重置</strong></p>\n<pre><code>p.reset() ; 将p重置为空指针，所管理对象引用计数 减1\np.reset(p1); 将p重置为p1（的值）,p 管控的对象计数减1，p接管对p1指针的管控\np.reset(p1,d); 将p重置为p1（的值），p 管控的对象计数减1并使用d作为删除器\np1是一个指针！\n</code></pre>\n<p><strong>交换</strong></p>\n<pre><code>p1 和 p2 是智能指针\n\nstd::swap(p1,p2); // 交换p1 和p2 管理的对象，原对象的引用计数不变\np1.swap(p2);    // 交换p1 和p2 管理的对象，原对象的引用计数不变\n</code></pre>\n<h3 id=\"shared_ptr使用陷阱\"><a class=\"anchor\" href=\"#shared_ptr使用陷阱\">#</a> shared_ptr 使用陷阱</h3>\n<p>shared_ptr 作为被管控的对象的成员时，小心因循环引用造成无法释放资源！</p>\n<p>如下代码：<br />\nBoy 类中有 Girl 的智能指针；<br />\nGirl 类中有 Boy 的智能指针；<br />\n当他们交叉互相持有对方的管理对象时…</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass Girl;\n\nclass Boy &#123;\npublic:\n\tBoy() &#123;\n\t\tcout &lt;&lt; &quot;Boy 构造函数&quot; &lt;&lt; endl;\n\t&#125;\n\n\t~Boy() &#123;\n\t\tcout &lt;&lt; &quot;~Boy 析构函数&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid setGirlFriend(shared_ptr&lt;Girl&gt; _girlFriend) &#123;\n\t\tthis-&gt;girlFriend = _girlFriend;\n\t&#125;\n\nprivate:\n\tshared_ptr&lt;Girl&gt; girlFriend;\n&#125;;\n\nclass Girl &#123;\npublic:\n\tGirl() &#123;\n\t\tcout &lt;&lt; &quot;Girl 构造函数&quot; &lt;&lt; endl;\n\t&#125;\n\n\t~Girl() &#123;\n\t\tcout &lt;&lt; &quot;~Girl 析构函数&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid setBoyFriend(shared_ptr&lt;Boy&gt; _boyFriend) &#123;\n\t\tthis-&gt;boyFriend = _boyFriend;\n\t&#125;\n\nprivate:\n\tshared_ptr&lt;Boy&gt; boyFriend;\n&#125;;\n\n\nvoid useTrap() &#123;\n\tshared_ptr&lt;Boy&gt; spBoy(new Boy());\n\tshared_ptr&lt;Girl&gt; spGirl(new Girl());\n\n\t// 陷阱用法\n\tspBoy-&gt;setGirlFriend(spGirl);\n\tspGirl-&gt;setBoyFriend(spBoy);\n\t// 此时boy和girl的引用计数都是2\n&#125;\n\n\nint main(void) &#123;\n\tuseTrap();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n\n</code></pre>\n<p>这段代码存在一个循环引用的问题，导致  <code>Boy</code>  对象和  <code>Girl</code>  对象互相持有对方的  <code>shared_ptr</code> ，从而导致了内存泄漏，因为它们的引用计数永远不会变为 0。</p>\n<p>具体来说，当  <code>useTrap()</code>  函数执行时，首先创建了一个  <code>shared_ptr&lt;Boy&gt;</code>  对象  <code>spBoy</code>  和一个  <code>shared_ptr&lt;Girl&gt;</code>  对象  <code>spGirl</code> 。然后，通过  <code>spBoy-&gt;setGirlFriend(spGirl)</code>  和  <code>spGirl-&gt;setBoyFriend(spBoy)</code>  分别将  <code>spGirl</code>  和  <code>spBoy</code>  传递给对方，这样就产生了循环引用的问题： <code>Boy</code>  对象持有  <code>Girl</code>  对象的  <code>shared_ptr</code> ，而  <code>Girl</code>  对象持有  <code>Boy</code>  对象的  <code>shared_ptr</code> 。因此，它们的引用计数都变成了 2，而不会减少到 0，导致它们的析构函数永远不会被调用，从而造成了内存泄漏。</p>\n<p>为了解决这个问题，可以使用  <code>weak_ptr</code>  来打破循环引用。 <code>weak_ptr</code>  是  <code>shared_ptr</code>  的一种弱引用，它可以监视  <code>shared_ptr</code>  的生命周期，但不会影响其引用计数。因此，可以将  <code>Girl</code>  类中的  <code>boyFriend</code>  成员改为  <code>weak_ptr&lt;Boy&gt;</code>  类型，从而避免循环引用的问题。</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nclass Girl;\n\nclass Boy &#123;\npublic:\n    Boy() &#123;\n        cout &lt;&lt; &quot;Boy 构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Boy() &#123;\n        cout &lt;&lt; &quot;~Boy 析构函数&quot; &lt;&lt; endl;\n    &#125;\n\n    void setGirlFriend(shared_ptr&lt;Girl&gt; _girlFriend) &#123;\n        this-&gt;girlFriend = _girlFriend;\n    &#125;\n\nprivate:\n    weak_ptr&lt;Girl&gt; girlFriend;\n&#125;;\n\nclass Girl &#123;\npublic:\n    Girl() &#123;\n        cout &lt;&lt; &quot;Girl 构造函数&quot; &lt;&lt; endl;\n    &#125;\n\n    ~Girl() &#123;\n        cout &lt;&lt; &quot;~Girl 析构函数&quot; &lt;&lt; endl;\n    &#125;\n\n    void setBoyFriend(shared_ptr&lt;Boy&gt; _boyFriend) &#123;\n        this-&gt;boyFriend = _boyFriend;\n    &#125;\n\nprivate:\n    weak_ptr&lt;Boy&gt; boyFriend;\n&#125;;\n\n\nvoid useTrap() &#123;\n    shared_ptr&lt;Boy&gt; spBoy(new Boy());\n    shared_ptr&lt;Girl&gt; spGirl(new Girl());\n\n    // 陷阱用法\n    spBoy-&gt;setGirlFriend(spGirl);\n    spGirl-&gt;setBoyFriend(spBoy);\n    // 此时boy和girl的引用计数都是2\n&#125;\n\n\nint main(void) &#123;\n    useTrap();\n\n    system(&quot;pause&quot;);\n    return 0;\n&#125;\n\n</code></pre>\n<p>当我们执行 useTrap 函数时，注意，是没有结束此函数，boy 和 girl 指针其实是被两个智能指针托管的，所以他们的引用计数是 2</p>\n<p><img loading=\"lazy\" data-src=\"https://img-blog.csdnimg.cn/f00ef1a424b2427cb7817c146bf28abb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>useTrap 函数结束后，函数中定义的智能指针被清掉，boy 和 girl 指针的引用计数减 1，还剩下 1，对象中的智能指针还是托管他们的，所以函数结束后没有将 boy 和 gilr 指针释放的原因就是于此</p>\n<p><img loading=\"lazy\" data-src=\"https://img-blog.csdnimg.cn/cd962cb9e0ae4610bebb40da2133e8a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\" /></p>\n<p>首先释放 spBoy，但是因为 girl 对象里面的智能指针还托管着 boy，boy 的引用计数为 2，所以释放 spBoy 时，引用计数减 1，boy 的引用计数为 1；<br />\n在释放 spGirl，girl 的引用计数减 1，为零，开始释放 girl 的内存，因为 girl 里面还包含有托管 boy 的智能指针对象，所以也会进行 boyFriend 的内存释放，boy 的引用计数减 1，为零，接着开始释放 boy 的内存。最终所有的内存都释放了。</p>\n<p>weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。 同时 weak_ptr 没有重载 * 和 -&gt; 但可以使用 lock 获得一个可用的 shared_ptr 对象。</p>\n<p>弱指针的使用；<br />\nweak_ptr wpGirl_1; // 定义空的弱指针<br />\n weak_ptr wpGirl_2 (spGirl); // 使用共享指针构造<br />\n wpGirl_1 = spGirl; // 允许共享指针赋值给弱指针</p>\n<p>弱指针也可以获得引用计数；<br />\nwpGirl_1.use_count()</p>\n<p>您是对的。 <code>weak_ptr</code>  是一种弱引用，它并不直接支持解引用操作 ( <code>*</code>  和  <code>-&gt;</code> )，因为它并不拥有被指向对象的所有权。相反， <code>weak_ptr</code>  主要用于监视由  <code>shared_ptr</code>  管理的对象的生命周期，而不会增加对象的引用计数。</p>\n<p>要访问  <code>weak_ptr</code>  所指向的对象，通常需要将  <code>weak_ptr</code>  转换为  <code>shared_ptr</code> 。可以通过  <code>lock()</code>  成员函数将  <code>weak_ptr</code>  转换为  <code>shared_ptr</code> ，然后使用  <code>shared_ptr</code>  的  <code>*</code>  和  <code>-&gt;</code>  运算符来访问所指向的对象。</p>\n<p>以下是一个示例：</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nusing namespace std;\n\nint main() &#123;\n    shared_ptr&lt;int&gt; sp(new int(42));\n    weak_ptr&lt;int&gt; wp = sp;\n\n    // 尝试解引用 weak_ptr\n    //int val = *wp;  // 错误：weak_ptr 不支持直接解引用\n    //cout &lt;&lt; &quot;Value: &quot; &lt;&lt; val &lt;&lt; endl;\n\n    // 尝试通过 -&gt; 运算符访问 weak_ptr 所指向的对象\n    //int val2 = wp-&gt;getValue(); // 错误：weak_ptr 不支持直接使用 -&gt; 运算符\n\n    // 将 weak_ptr 转换为 shared_ptr\n    shared_ptr&lt;int&gt; sp2 = wp.lock();\n    if (sp2) &#123;\n        // 成功获取 shared_ptr，现在可以使用 * 和 -&gt; 运算符访问所指向的对象\n        int val3 = *sp2;\n        cout &lt;&lt; &quot;Value: &quot; &lt;&lt; val3 &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;The shared_ptr is expired.&quot; &lt;&lt; endl;\n    &#125;\n\n    return 0;\n&#125;\n\n</code></pre>\n<p>在上面的示例中，我们使用了  <code>lock()</code>  函数将  <code>weak_ptr</code>  转换为  <code>shared_ptr</code> ，然后使用  <code>shared_ptr</code>  的  <code>*</code>  运算符来解引用  <code>shared_ptr</code>  对象并访问所指向的对象的值。这样做的好处是，在转换为  <code>shared_ptr</code>  时，我们同时增加了被指向对象的引用计数，确保在  <code>shared_ptr</code>  存活期间对象不会被销毁。</p>\n<p>expired 函数的用法<br />\n应评论区某位朋友的要求，现在加上 weak_ptr 指针的 expired 函数的用法！</p>\n<p>expired：判断当前 weak_ptr 智能指针是否还有托管的对象，有则返回 false，无则返回 true</p>\n<p>如果返回 true，等价于 use_count () == 0，即已经没有托管的对象了；当然，可能还有析构函数进行释放内存，但此对象的析构已经临近（或可能已发生）。</p>\n<p>示例<br />\n演示如何用 expired 检查指针的合法性。<br />\n在网上找了一段代码，加上自己的注释理解</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstd::weak_ptr&lt;int&gt; gw;\n\nvoid f() &#123;\n\n\t// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true\n\tif (!gw.expired()) &#123;\n\t\tstd::cout &lt;&lt; &quot;gw is valid\\n&quot;;\t// 有效的，还有托管的指针\n\t&#125; else &#123;\n\t\tstd::cout &lt;&lt; &quot;gw is expired\\n&quot;;\t// 过期的，没有托管的指针\n\t&#125;\n&#125;\n\nint main() &#123;\n\t&#123;\n\t\tauto sp = std::make_shared&lt;int&gt;(42);\n\t\tgw = sp;\n\n\t\tf();\n\t&#125;\n\n\t// 当&#123; &#125;体中的指针生命周期结束后，再来判断其是否还有托管的指针\n\tf();\n\n\treturn 0;\n&#125;\n\n</code></pre>\n<p>六、智能指针的使用陷阱<br />\n不要把一个原生指针给多个智能指针管理；</p>\n<p>int *x = new int(10);<br />\nunique_ptr&lt; int &gt; up1(x);<br />\nunique_ptr&lt; int &gt; up2(x);<br />\n// 警告！以上代码使 up1 up2 指向同一个内存，非常危险<br />\n或以下形式：<br />\nup1.reset(x);<br />\nup2.reset(x);</p>\n<p>记得使用 u.release () 的返回值；<br />\n 在调用 u.release () 时是不会释放 u 所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就泄漏了.</p>\n<p>禁止 delete 智能指针 get 函数返回的指针；<br />\n 如果我们主动释放掉 get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放，带来严重后果！</p>\n<p>禁止用任何类型智能指针 get 函数返回的指针去初始化另外一个智能指针！<br />\nshared_ptr&lt; int &gt; sp1(new int(10));<br />\n// 一个典型的错误用法 shared_ptr&lt;int&gt; sp4 (sp1.get ());<br />\n————————————————</p>\n<pre><code>                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。\n</code></pre>\n<p>原文链接：<a href=\"https://blog.csdn.net/cpp_learner/article/details/118912592\">https://blog.csdn.net/cpp_learner/article/details/118912592</a></p>\n<p>智能指针虽然使用起来很方便，但是要注意使用智能指针的一些陷阱，否则会造成严重的内存报错或者内存泄露等问题！</p>\n<p>某最大矩阵写的暴力</p>\n<pre><code class=\"language-c++\">#include &lt;vector&gt;\nusing namespace std;\n\nclass Solution &#123;\npublic:\n    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;\n        int n = matrix.size();\n        if (n == 0) return 0;\n        int m = matrix[0].size();\n        if (m == 0) return 0;\n\n        // 将字符矩阵转换为整数矩阵\n        vector&lt;vector&lt;int&gt;&gt; f(n + 1, vector&lt;int&gt;(m + 1, 0));\n        for (int i = 1; i &lt;= n; i++)\n            for (int j = 1; j &lt;= m; j++)\n                f[i][j] = matrix[i - 1][j - 1] - '0';\n\n        int ans = 0;\n\n        // 先更新前缀和\n        for (int i = 1; i &lt;= n; i++)\n            for (int j = 1; j &lt;= m; j++)\n                f[i][j] += f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1];\n\n        for (int i = 1; i &lt;= n; i++) &#123;\n            for (int j = 1; j &lt;= m; j++) &#123;\n                // 确定一个点，枚举边长\n                for (int k = 1; k &lt;= min(n - i + 1, m - j + 1); k++) &#123;\n                    // 枚举边长\n                    int x1 = i, x2 = i + k - 1, y1 = j, y2 = j + k - 1;\n                    // 确定四个点\n                    int sum = f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1];\n                    // 计算面积\n                    if (sum == k * k)\n                        ans = max(ans, sum);\n                    if (sum != k * k)\n                        break;\n                    // 更新答案\n                &#125;\n            &#125;\n        &#125;\n\n        return ans;\n    &#125;\n&#125;;\n\n</code></pre>\n<h3 id=\"神奇的dp\"><a class=\"anchor\" href=\"#神奇的dp\">#</a> 神奇的 DP</h3>\n",
            "tags": []
        },
        {
            "id": "https://lysistic.github.io/2024/03/03/hello-world/",
            "url": "https://lysistic.github.io/2024/03/03/hello-world/",
            "title": "Hello World",
            "date_published": "2024-03-02T18:01:38.910Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        },
        {
            "id": "https://lysistic.github.io/2024/03/03/git-learn/",
            "url": "https://lysistic.github.io/2024/03/03/git-learn/",
            "title": "git-learn",
            "date_published": "2024-03-02T16:14:01.000Z",
            "content_html": "<p>WorkSpace: 工作区  index/Stage: 暂存区 Repository: 仓库区 Remote: 远程仓库</p>\n<h2 id=\"git-init-初始化\"><a class=\"anchor\" href=\"#git-init-初始化\">#</a>  <code>git init 初始化</code></h2>\n<p>.git  Git 用来跟踪管理版本</p>\n<p><code>git add readme.txt 添加文本</code></p>\n<p><code>git commit -m 'hello world'</code></p>\n<p><code>git status 查看是否还有文件未提交</code></p>\n<p><code>git diff readme.txt 查看修改</code></p>\n<p><code>git log 查看历史日志</code></p>\n<p><code>git log -pretty=oneline 单行显示</code></p>\n<h2 id=\"版本回退\"><a class=\"anchor\" href=\"#版本回退\">#</a> 版本回退</h2>\n<p><code>git reset --hard HEAD^ 回退一个版本</code></p>\n<p><code>git reset --hard HEAD^^ 回退两个版本</code></p>\n<p><code>git reset --hard HEAD~100 回退到前100个版本</code></p>\n<p><code>git reset --hard 版本号</code></p>\n<p><code>git reflog 获取各个版本版本号</code></p>\n<ul>\n<li>工作区：就是你在电脑上看到的目录，比如目录下 testgit 里的文件 (.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。</li>\n<li>版本库 (Repository)：工作区有一个隐藏目录.git, 这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage (暂存区)，还有 Git 为我们自动创建了第一个分支 master, 以及指向 master 的一个指针 HEAD。</li>\n</ul>\n<p><code>git commit 一次性提交</code></p>\n<p><code>git checkout --filename </code></p>\n<p><code>eg: git checkout --readme.txt 撤销提交</code></p>\n<p><code>git checkout --file_deleted 恢复被撤销的文件</code></p>\n<p><code>git remote add origin url</code></p>\n<p><code>git push -u origin master 推送本地仓库master分支</code></p>\n<p><code>先本地commit 再 git push origin master</code></p>\n<p><code>git clone url</code></p>\n<p><code>git checkout -b dev 创建并切换分支</code></p>\n<p><code>git branch 查看当前分支</code></p>\n<p>-b 参数表示切换</p>\n<p>创建分支</p>\n<p><code>git branch dev</code></p>\n<p>切换分支</p>\n<p><code>git checkout dev</code></p>\n<p><code>git merge dev 合并指定分支到主分支上</code></p>\n<p><code>git branch -d dev</code>  删除 dev 分支</p>\n<p>conclusion</p>\n<ul>\n<li>\n<p><code>查看分支 git branch</code></p>\n</li>\n<li>\n<p><code>创建分支 git branch name</code></p>\n</li>\n<li>\n<p><code>切换分支 git checkout name</code></p>\n</li>\n<li>\n<p><code>创建+切换分支 git checkout -b name</code></p>\n</li>\n<li>\n<p><code>合并某分支到当前分支 git merge name</code></p>\n</li>\n<li>\n<p><code>删除分支 git branch -d name</code></p>\n</li>\n<li>\n<p><code>git merge --no-ff -m &quot;eaewea with no-ff&quot; dev 禁用fast forward</code></p>\n</li>\n<li>\n<p><code>git log --graph --pretty=oneline --abbrev-commit</code>  是一个 Git 命令，用于查看提交历史，并以图形化的方式显示提交历史，并指定了显示格式和提交 ID 的缩写。</p>\n<p>解读这个命令的各个参数：</p>\n<ul>\n<li><code>git log</code> : 显示提交历史记录。</li>\n<li><code>--graph</code> : 使用图形化的方式显示提交历史。这会在输出中添加一些字符来表示提交历史的分支和合并关系，使其更易于理解。</li>\n<li><code>--pretty=oneline</code> : 指定输出格式为单行显示。这会以紧凑的方式显示提交历史，每个提交占据一行，每行显示一个提交的摘要信息。</li>\n<li><code>--abbrev-commit</code> : 缩写提交 ID。这会使提交 ID 的长度缩短，只显示前几个字符，以提高显示的紧凑性和可读性。</li>\n</ul>\n</li>\n<li>\n<p><code>git stash 将当前工作现场隐藏起来</code></p>\n</li>\n<li>\n<p><code>git status</code>  是干净的</p>\n</li>\n<li>\n<p><code>git checkout -b filename 创建bug修复分支</code></p>\n</li>\n<li>\n<p>bug 修复后，切换到 master 分支，完成合并，再删除 bug 修复分支</p>\n</li>\n<li>\n<p><code>git stash list</code></p>\n</li>\n<li>\n<p><code>git stash apply 恢复</code></p>\n</li>\n<li>\n<p><code>git stash drop 删除</code></p>\n</li>\n<li>\n<p><code>或者直接 git stash pop 恢复的同时删除</code></p>\n</li>\n<li>\n<p><code>git remote 查看远程仓库的信息</code></p>\n</li>\n<li>\n<p><code>git remote -v 查看远程仓库的详细信息</code></p>\n</li>\n<li>\n<p><code>git push origin master</code></p>\n</li>\n<li>\n<p><code>git push origin dev 推送不同分支 多台机器合作</code></p>\n</li>\n<li>\n<p><code>git branch --set-upsteam dev origin/dev 指定本地dev分支与远程origin/dev分支的联系</code></p>\n</li>\n<li>\n<p>[<a href=\"https://www.cnblogs.com/tugenhua0707/p/4050072.html\">Git 使用教程 - 龙恩 0707 - 博客园 (cnblogs.com)</a>](<a href=\"https://www.cnblogs.com/tugenhua0707/p/4050072.html\">https://www.cnblogs.com/tugenhua0707/p/4050072.html</a>)</p>\n</li>\n</ul>\n<p><a href=\"https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">常用 Git 命令清单 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<pre><code>一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name] # 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n二、配置\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global] # 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n\n三、增加/删除文件\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录\n$ git add [dir] # 添加当前目录的所有文件到暂存区\n$ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n四、代码提交\n# 提交暂存区到仓库区\n$ git commit -m [message] # 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n五、分支\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name] # 新建一个分支，并切换到该分支\n$ git checkout -b [branch] # 新建一个分支，指向指定commit\n$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区\n$ git checkout [branch-name] # 切换到上一个分支\n$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支\n$ git merge [branch] # 选择一个commit，合并进当前分支\n$ git cherry-pick [commit] # 删除分支\n$ git branch -d [branch-name] # 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n六、标签\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag] # 新建一个tag在指定commit\n$ git tag [tag] [commit] # 删除本地tag\n$ git tag -d [tag] # 删除远程tag\n$ git push origin :refs/tags/[tagName] # 查看tag信息\n$ git show [tag] # 提交指定tag\n$ git push [remote] [tag] # 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n七、查看信息\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file] # 显示指定文件相关的每一次diff\n$ git log -p [file] # 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file] # 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot; # 显示某次提交的元数据和内容变化\n$ git show [commit] # 显示某次提交发生变化的文件\n$ git show --name-only [commit] # 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename] # 显示当前分支的最近几次提交\n$ git reflog\n\n八、远程同步\n# 下载远程仓库的所有变动\n$ git fetch [remote] # 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote] # 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch] # 上传本地指定分支到远程仓库\n$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n九、撤销\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区\n$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://lysistic.github.io/2024/02/12/my-first-article/",
            "url": "https://lysistic.github.io/2024/02/12/my-first-article/",
            "title": "my first article",
            "date_published": "2024-02-12T10:14:24.000Z",
            "content_html": "<h2 id=\"this-is-my-first-blog\"><a class=\"anchor\" href=\"#this-is-my-first-blog\">#</a> This is my first blog.</h2>\n<ul>\n<li>Hello World！</li>\n</ul>\n",
            "tags": []
        }
    ]
}