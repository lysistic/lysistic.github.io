<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>Lystics</title>
        <subtitle></subtitle>
        <icon>https://lysistic.github.io/assets/favicon.ico</icon>
        <link>https://lysistic.github.io</link>
        <author>
          <name>lystics</name>
        </author>
        <description></description>
        <language>zh</language>
        <pubDate>Sun, 03 Mar 2024 13:05:40 +0800</pubDate>
        <lastBuildDate>Sun, 03 Mar 2024 13:05:40 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">https://lysistic.github.io/2024/03/03/cpp-O-o/</guid>
            <title>cpp_O.o</title>
            <link>https://lysistic.github.io/2024/03/03/cpp-O-o/</link>
            <pubDate>Sun, 03 Mar 2024 13:05:40 +0800</pubDate>
            <description><![CDATA[ &lt;ul&gt;
&lt;li&gt;istream // 输入流类型，提供输入操作&lt;/li&gt;
&lt;li&gt;ifstream // 由 istream 派生而来，提供文件读入功能&lt;/li&gt;
&lt;li&gt;ostream // 输出流类型，提供输出操作&lt;/li&gt;
&lt;li&gt;ofstream // 由 ostream 派生而来，提供文件写功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt; 用于从istream对象读入&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt; 用于把输出写道ostream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;iostream 定义读写控制窗口类型&lt;/p&gt;
&lt;p&gt;fstream 定义读写已命名文件类型&lt;/p&gt;
&lt;p&gt;sstream 所定义的类型读写存储在内存中的 string 对象&lt;/p&gt;
&lt;h1 id=&#34;智能指针&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#智能指针&#34;&gt;#&lt;/a&gt; 智能指针&lt;/h1&gt;
&lt;p&gt;智能指针就是帮我们 C++ 程序员管理动态分配的内存的，它会帮助我们自动释放 new 出来的内存，从而&lt;strong&gt;避免内存泄漏&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;内存泄漏的例子&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;memory&amp;gt;
using namespace std;
// 动态分配内存，没有释放就return
void memoryLeak1() &amp;#123;
	string *str = new string(&amp;quot;动态分配内存！&amp;quot;);
	return;
&amp;#125;
// 动态分配内存，虽然有些释放内存的代码，但是被半路截胡return了
int memoryLeak2() &amp;#123;
	string *str = new string(&amp;quot;内存泄露！&amp;quot;);
	// ...此处省略一万行代码
	// 发生某些异常，需要结束函数
	if (1) &amp;#123;
		return -1;
	&amp;#125;
	/
	// 另外，使用try、catch结束函数，也会造成内存泄漏！
	/

	delete str;	// 虽然写了释放内存的代码，但是遭到函数中段返回，使得指针没有得到释放
	return 1;
&amp;#125;


int main(void) &amp;#123;

	memoryLeak1();

	memoryLeak2();

	return 0;
&amp;#125; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用指针并申请空间，用完没有释放就会造成内存泄漏。&lt;/p&gt;
&lt;p&gt;一个可行的方案：&lt;/p&gt;
&lt;p&gt;动态分配的内存都交由有生命周期的对象来处理，在对象过期时，让他的析构函数删除指向的内存。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C++98 提供了 auto_ptr 模板的解决方案&lt;/li&gt;
&lt;li&gt;C++11 增加 unique_ptr、shared_ptr 和 weak_ptr&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;auto_ptr&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#auto_ptr&#34;&gt;#&lt;/a&gt; auto_ptr&lt;/h2&gt;
&lt;p&gt;auto_ptr 是 c++ 98 定义的智能指针模板，其定义了管理指针的对象，可以将 new 获得（直接或间接）的地址赋给这种对象。当对象过期时，其析构函数将使用 delete 来释放内存&lt;/p&gt;
&lt;p&gt;用法:&lt;br /&gt;
 头文件: #include &amp;lt;memory&amp;gt;&lt;br /&gt;
 用 法: auto_ptr &amp;lt;类型&amp;gt; 变量名 (new 类型)&lt;/p&gt;
&lt;p&gt;例 如:&lt;br /&gt;
auto_ptr&amp;lt;string&amp;gt; str (new string (“我要成为大牛～变得很牛逼！”));&lt;br /&gt;
auto_ptr&amp;lt;vector&amp;lt; int &amp;gt;&amp;gt; av(new vector&amp;lt; int &amp;gt;());&lt;br /&gt;
auto_ptr&amp;lt; int &amp;gt; array(new int[10]);&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;mem.h&amp;gt;
#include&amp;lt;io.h&amp;gt;
#include&amp;lt;memory&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
using namespace std;
class Test &amp;#123;
public:
	Test() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;gouzao&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;
	~Test() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;xigou...&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;

	int getDebug() &amp;#123; return this-&amp;gt;debug; &amp;#125;

private:
	int debug = 20;
&amp;#125;;

using namespace std;
// 定义智能指针
int main(void) &amp;#123;

	//Test *test = new Test;
	auto_ptr&amp;lt;Test&amp;gt; test(new Test);

	cout &amp;lt;&amp;lt; &amp;quot;test-&amp;gt;debug：&amp;quot; &amp;lt;&amp;lt; test-&amp;gt;getDebug() &amp;lt;&amp;lt; endl;
	cout &amp;lt;&amp;lt; &amp;quot;(*test).debug：&amp;quot; &amp;lt;&amp;lt; (*test).getDebug() &amp;lt;&amp;lt; endl;

	return 0;
&amp;#125; 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在程序退出时调用析构函数释放内存&lt;/p&gt;
&lt;p&gt;智能指针常用的三个函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get&lt;/strong&gt; () 获取智能指针托管的指针地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;release&lt;/strong&gt; () 取消智能指针对动态内存的托管&lt;strong&gt; reset&lt;/strong&gt; () 重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto_ptr&lt;/code&gt;  是 C++11 之前的标准库中的智能指针，它具有独占性质，即不能被多个指针共享。因此，将  &lt;code&gt;auto_ptr&lt;/code&gt;  变量定义为全局变量或指针可能会导致一些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;所有权的问题&lt;/strong&gt;： &lt;code&gt;auto_ptr&lt;/code&gt;  采用了独占所有权的策略，当一个  &lt;code&gt;auto_ptr&lt;/code&gt;  对象被赋值给另一个  &lt;code&gt;auto_ptr&lt;/code&gt;  对象时，原来的  &lt;code&gt;auto_ptr&lt;/code&gt;  对象就失去了对资源的控制权。如果将  &lt;code&gt;auto_ptr&lt;/code&gt;  定义为全局变量，那么在程序的不同部分可能会意外地修改或释放全局变量指向的资源，导致不可预测的行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;析构顺序问题&lt;/strong&gt;：全局变量的析构顺序是未定义的，而  &lt;code&gt;auto_ptr&lt;/code&gt;  的析构函数会释放其所管理的资源。如果  &lt;code&gt;auto_ptr&lt;/code&gt;  的析构函数被调用时，其他全局变量还在使用这个资源，可能会导致未定义的行为或内存错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程安全问题&lt;/strong&gt;：全局变量的访问可能不是线程安全的，如果多个线程同时访问全局变量，可能会发生竞态条件。而  &lt;code&gt;auto_ptr&lt;/code&gt;  的操作并不是线程安全的，因此在多线程环境下，使用全局的  &lt;code&gt;auto_ptr&lt;/code&gt;  可能会导致竞态条件，从而导致资源泄漏或内存错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于上述问题，尽可能不要将  &lt;code&gt;auto_ptr&lt;/code&gt;  变量定义为全局变量或指针。相反，应该将  &lt;code&gt;auto_ptr&lt;/code&gt;  定义为局部变量，以便在离开作用域时自动释放资源，并避免共享资源的所有权。在 C++11 之后，推荐使用更安全的智能指针，如  &lt;code&gt;unique_ptr&lt;/code&gt;  或  &lt;code&gt;shared_ptr&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;除非自己知道后果，不要把 auto_ptr 智能指针赋值给同类型的另外一个 智能指针&lt;/p&gt;
&lt;p&gt;正是的。 &lt;code&gt;auto_ptr&lt;/code&gt;  是一种具有独占所有权的智能指针，它的特性决定了它只能被移动，而不能被复制。当你将一个  &lt;code&gt;auto_ptr&lt;/code&gt;  赋值给另一个  &lt;code&gt;auto_ptr&lt;/code&gt;  时，所有权会从一个指针转移到另一个指针，原始指针会失去所有权。&lt;/p&gt;
&lt;p&gt;这种转移所有权的行为可能导致一些潜在的问题，尤其是在程序的不同部分使用了同一个资源时。具体来说，可能会出现以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;悬空指针（Dangling Pointer）&lt;/strong&gt;：如果不小心将一个  &lt;code&gt;auto_ptr&lt;/code&gt;  赋值给另一个  &lt;code&gt;auto_ptr&lt;/code&gt; ，并且原始指针在后续的使用中还会被访问，那么就可能出现悬空指针的问题，即指向已经释放的内存的指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源泄漏（Resource Leak）&lt;/strong&gt;：如果不正确地管理  &lt;code&gt;auto_ptr&lt;/code&gt; ，可能会导致资源泄漏。例如，在将  &lt;code&gt;auto_ptr&lt;/code&gt;  赋值给另一个  &lt;code&gt;auto_ptr&lt;/code&gt;  之后，原始指针没有被释放，导致资源无法释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不确定的行为（Undefined Behavior）&lt;/strong&gt;：由于  &lt;code&gt;auto_ptr&lt;/code&gt;  的独占性质，可能会导致在不同的地方意外地释放资源或者使用已经释放的资源，从而导致不确定的行为。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，除非你清楚地了解后果并能够确保安全使用，否则不要将  &lt;code&gt;auto_ptr&lt;/code&gt;  智能指针赋值给同类型的另一个智能指针。在现代 C++ 中，推荐使用更安全的智能指针，如  &lt;code&gt;unique_ptr&lt;/code&gt;  或  &lt;code&gt;shared_ptr&lt;/code&gt; ，它们提供了更严格的所有权控制，并且避免了  &lt;code&gt;auto_ptr&lt;/code&gt;  可能带来的问题&lt;/p&gt;
&lt;p&gt;C&lt;ins&gt;11 后 auto_ptr 已经被 “抛弃”，已使用 unique_ptr 替代！C&lt;/ins&gt;11 后不建议使用 auto_ptr&lt;/p&gt;
&lt;h3 id=&#34;auto_ptr-被c11抛弃的主要原因&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#auto_ptr-被c11抛弃的主要原因&#34;&gt;#&lt;/a&gt; &lt;strong&gt;auto_ptr 被 C++11 抛弃的主要原因&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;复制或者赋值都会改变资源的所有权&lt;/p&gt;
&lt;p&gt;在 STL 容器中使用 auto_ptr 存在着重大风险，因为容器内的元素必须支持可复制和可赋值&lt;/p&gt;
&lt;p&gt;在 C++ 中，左值（lvalue）和右值（rvalue）是用于描述表达式的术语。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;左值（lvalue）&lt;/strong&gt;：左值是指可以被赋值的表达式，通常是可以取地址的表达式。具体来说，左值是一个具有标识符（即有名称）并且可以通过地址获取其值的表达式。例如，变量、数组元素、函数返回的引用等都是左值。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cppCopy codeint x = 5; // x是左值
int arr[5]; // arr是左值
int&amp;amp; ref = x; // ref是左值
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;右值（rvalue）&lt;/strong&gt;：右值是指不能被赋值的表达式，通常是临时的、一次性的值。右值没有名称，通常在表达式求值后就消失了。例如，常量、临时对象、函数返回的非引用值等都是右值。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cppCopy code5 + 3; // 5 + 3是右值
int* ptr = new int(10); // new int(10)返回的是右值
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 C++11 中引入了右值引用（rvalue references），它允许我们更方便地处理右值，并且可以实现移动语义，提高程序的性能。右值引用使用  &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;  来声明，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cppCopy code
int&amp;amp;&amp;amp; rv = 5; // rv是右值引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 C++ 中，直接将右值绑定到左值引用是不允许的。因为左值引用是用于引用左值的，而右值是临时的、一次性的值，不具备地址，无法通过引用来访问。试图将右值直接绑定到左值引用会导致编译错误。&lt;/p&gt;
&lt;p&gt;例如，以下代码会导致编译错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cppCopy code
int&amp;amp; rv = 5; // 错误：无法将右值绑定到左值引用
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正确的做法是使用右值引用来绑定右值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cppCopy code
int&amp;amp;&amp;amp; rv = 5; // 正确：使用右值引用绑定右值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者，你可以使用  &lt;code&gt;const&lt;/code&gt;  修饰左值引用，这样就可以将右值绑定到  &lt;code&gt;const&lt;/code&gt;  左值引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cppCopy code
const int&amp;amp; rv = 5; // 正确：使用const左值引用绑定右值
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样做是合法的，因为  &lt;code&gt;const&lt;/code&gt;  左值引用可以延长右值的生命周期，使其与引用的生命周期相匹配。&lt;/p&gt;
&lt;p&gt;不支持对象数组的内存管理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

class Test &amp;#123;
public:
	Test() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;Test的构造函数...&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;
	~Test() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;Test的析构函数...&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;

	int getDebug() &amp;#123; return this-&amp;gt;debug; &amp;#125;

private:
	int debug = 20;
&amp;#125;;

// 不要定义为全局变量，没有意义
//auto_ptr&amp;lt;Test&amp;gt; test(new Test);

void memoryLeak1() &amp;#123;
	//Test *test = new Test;

	// 定义智能指针
	auto_ptr&amp;lt;Test&amp;gt; test(new Test);
	
	cout &amp;lt;&amp;lt; &amp;quot;test-&amp;gt;debug：&amp;quot; &amp;lt;&amp;lt; test-&amp;gt;getDebug() &amp;lt;&amp;lt; endl;
	cout &amp;lt;&amp;lt; &amp;quot;(*test).debug：&amp;quot; &amp;lt;&amp;lt; (*test).getDebug() &amp;lt;&amp;lt; endl;


	// get方法
	Test *tmp = test.get();		// 获取指针返回
	cout &amp;lt;&amp;lt; &amp;quot;tmp-&amp;gt;debug：&amp;quot; &amp;lt;&amp;lt; tmp-&amp;gt;getDebug() &amp;lt;&amp;lt; endl;


	// release方法
	Test *tmp2 = test.release();	// 取消智能指针对动态内存的托管
	delete tmp2;	// 之前分配的内存需要自己手动释放


	// reset方法：重置智能指针托管的内存地址，如果地址不一致，原来的会被析构掉
	test.reset();			// 释放掉智能指针托管的指针内存，并将其置NULL
	test.reset(new Test());	// 释放掉智能指针托管的指针内存，并将参数指针取代之


	// 忠告：不要将智能指针定义为指针
	//auto_ptr&amp;lt;Test&amp;gt; *tp = new auto_ptr&amp;lt;Test&amp;gt;(new Test);

	// 忠告：不要定义指向智能指针对象的指针变量
	//auto_ptr&amp;lt;Test&amp;gt; t1(new Test);
	//auto_ptr&amp;lt;Test&amp;gt; t2(new Test);
	//t1 = t2;

	return;
&amp;#125;

int memoryLeak2() &amp;#123;
	//Test *test = new Test();

	// 定义智能指针
	auto_ptr&amp;lt;Test&amp;gt; test(new Test);

	// ...此处省略一万行代码

	// 发生某些异常，需要结束函数
	if (1) &amp;#123;
		return -1;
	&amp;#125;

	//delete test;
	return 1;
&amp;#125;


int main1(void) &amp;#123;

	//memoryLeak1();

	//memoryLeak2();

	//Test *test = new Test;
	//auto_ptr&amp;lt;Test&amp;gt; test(new Test);

	//cout &amp;lt;&amp;lt; &amp;quot;test-&amp;gt;debug：&amp;quot; &amp;lt;&amp;lt; test-&amp;gt;getDebug() &amp;lt;&amp;lt; endl;
	//cout &amp;lt;&amp;lt; &amp;quot;(*test).debug：&amp;quot; &amp;lt;&amp;lt; (*test).getDebug() &amp;lt;&amp;lt; endl;


	 auto_ptr 被C++11抛弃的主要原因
	//auto_ptr&amp;lt;string&amp;gt; p1(new string(&amp;quot;I&#39;m Li Ming!&amp;quot;));
	//auto_ptr&amp;lt;string&amp;gt; p2(new string(&amp;quot;I&#39;m age 22.&amp;quot;));
	//
	//cout &amp;lt;&amp;lt; &amp;quot;p1：&amp;quot; &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
	//cout &amp;lt;&amp;lt; &amp;quot;p2：&amp;quot; &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

	//p1 = p2;
	//cout &amp;lt;&amp;lt; &amp;quot;p1 = p2 赋值后：&amp;quot; &amp;lt;&amp;lt; endl;
	//cout &amp;lt;&amp;lt; &amp;quot;p1：&amp;quot; &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
	//cout &amp;lt;&amp;lt; &amp;quot;p2：&amp;quot; &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;



	// 弊端2.在STL容器中使用auto_ptr存在着重大风险，因为容器内的元素必须支持可复制
	vector&amp;lt;auto_ptr&amp;lt;string&amp;gt;&amp;gt; vec;
	auto_ptr&amp;lt;string&amp;gt; p3(new string(&amp;quot;I&#39;m P3&amp;quot;));
	auto_ptr&amp;lt;string&amp;gt; p4(new string(&amp;quot;I&#39;m P4&amp;quot;));

	vec.push_back(std::move(p3));
	vec.push_back(std::move(p4));

	cout &amp;lt;&amp;lt; &amp;quot;vec.at(0)：&amp;quot; &amp;lt;&amp;lt;  *vec.at(0) &amp;lt;&amp;lt; endl;
	cout &amp;lt;&amp;lt; &amp;quot;vec[1]：&amp;quot; &amp;lt;&amp;lt;  *vec[1] &amp;lt;&amp;lt; endl;


	// 风险来了：
	vec[0] = vec[1];
	cout &amp;lt;&amp;lt; &amp;quot;vec.at(0)：&amp;quot; &amp;lt;&amp;lt; *vec.at(0) &amp;lt;&amp;lt; endl;
	cout &amp;lt;&amp;lt; &amp;quot;vec[1]：&amp;quot; &amp;lt;&amp;lt; *vec[1] &amp;lt;&amp;lt; endl;


	// 弊端3.不支持对象数组的内存管理
	//auto_ptr&amp;lt;int[]&amp;gt; array(new int[5]);	// 不能这样定义
	return 0;
&amp;#125; 


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;三、unique_ptr&lt;br /&gt;
auto_ptr 是用于 C++11 之前的智能指针。由于 auto_ptr 基于排他所有权模式：两个指针不能指向同一个资源，复制或赋值都会改变资源的所有权。auto_ptr 主要有三大问题：&lt;/p&gt;
&lt;p&gt;复制和赋值会改变资源的所有权，不符合人的直觉。&lt;br /&gt;
在 STL 容器中使用 auto_ptr 存在重大风险，因为容器内的元素必需支持可复制（copy constructable）和可赋值（assignable）。&lt;br /&gt;
不支持对象数组的操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;所有权语义&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;  使用独占所有权语义，即一个  &lt;code&gt;auto_ptr&lt;/code&gt;  指针拥有对其所管理资源的唯一所有权。这意味着一个  &lt;code&gt;auto_ptr&lt;/code&gt;  对象的所有权可以从一个对象转移到另一个对象，但不能共享资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;  也使用独占所有权语义，但它提供了更严格的所有权管理。例如， &lt;code&gt;unique_ptr&lt;/code&gt;  的拷贝构造函数和赋值操作符都被删除了，因此不能像  &lt;code&gt;auto_ptr&lt;/code&gt;  那样直接赋值或拷贝。相反， &lt;code&gt;unique_ptr&lt;/code&gt;  只能通过移动来转移所有权。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除拷贝构造函数和赋值操作符&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在  &lt;code&gt;unique_ptr&lt;/code&gt;  中，拷贝构造函数和赋值操作符被显式地删除了，这意味着  &lt;code&gt;unique_ptr&lt;/code&gt;  不能进行拷贝或赋值操作，只能通过移动语义来转移资源的所有权。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;  允许拷贝和赋值，但它的拷贝语义并不安全，可能会导致悬空指针问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义删除器&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;  允许你指定一个自定义删除器，用于释放资源时的操作。这使得  &lt;code&gt;unique_ptr&lt;/code&gt;  可以管理动态分配的数组以及其他需要特殊处理的资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;  没有提供类似的功能，它只能用于管理单个动态分配的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上所述，虽然  &lt;code&gt;unique_ptr&lt;/code&gt;  和  &lt;code&gt;auto_ptr&lt;/code&gt;  在某些方面类似，但由于  &lt;code&gt;unique_ptr&lt;/code&gt;  提供了更严格的所有权管理和更安全的拷贝语义，因此在 C++11 中推荐使用  &lt;code&gt;unique_ptr&lt;/code&gt; ，而不是  &lt;code&gt;auto_ptr&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unique_ptr&amp;lt;string&amp;gt; p1(new string(&amp;quot;I&#39;m Li Ming!&amp;quot;));
unique_ptr&amp;lt;string&amp;gt; p2(new string(&amp;quot;I&#39;m age 22.&amp;quot;));
	
cout &amp;lt;&amp;lt; &amp;quot;p1：&amp;quot; &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;p2：&amp;quot; &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

p1 = p2;					// 禁止左值赋值
unique_ptr&amp;lt;string&amp;gt; p3(p2);	// 禁止左值赋值构造

unique_ptr&amp;lt;string&amp;gt; p3(std::move(p1));
p1 = std::move(p2);	// 使用move把左值转成右值就可以赋值了，效果和auto_ptr赋值一样

cout &amp;lt;&amp;lt; &amp;quot;p1 = p2 赋值后：&amp;quot; &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;p1：&amp;quot; &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;p2：&amp;quot; &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考图片&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;C:%5CUsers%5Clystics%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240303154043937.png&#34; alt=&#34;image-20240303154043937&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B&lt;/strong&gt;. 在 STL 容器中使用 unique_ptr，不允许直接赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vector&amp;lt;unique_ptr&amp;lt;string&amp;gt;&amp;gt; vec;
unique_ptr&amp;lt;string&amp;gt; p3(new string(&amp;quot;I&#39;m P3&amp;quot;));
unique_ptr&amp;lt;string&amp;gt; p4(new string(&amp;quot;I&#39;m P4&amp;quot;));

vec.push_back(std::move(p3));
vec.push_back(std::move(p4));

cout &amp;lt;&amp;lt; &amp;quot;vec.at(0)：&amp;quot; &amp;lt;&amp;lt; *vec.at(0) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;vec[1]：&amp;quot; &amp;lt;&amp;lt; *vec[1] &amp;lt;&amp;lt; endl;

vec[0] = vec[1];	/* 不允许直接赋值 */
vec[0] = std::move(vec[1]);		// 需要使用move修饰，使得程序员知道后果

cout &amp;lt;&amp;lt; &amp;quot;vec.at(0)：&amp;quot; &amp;lt;&amp;lt; *vec.at(0) &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;vec[1]：&amp;quot; &amp;lt;&amp;lt; *vec[1] &amp;lt;&amp;lt; endl;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 C++ 中， &lt;code&gt;std::move&lt;/code&gt;  是一个函数模板，它用于将一个左值转换为右值引用，以便进行移动语义的操作。它并不执行移动操作，而只是告诉编译器你有意进行移动操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt;  的作用主要有两个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标记对象为右值&lt;/strong&gt;：使用  &lt;code&gt;std::move&lt;/code&gt;  可以将一个左值转换为右值引用，告诉编译器你有意将其移动，而不是复制。这在实现移动语义时非常有用，因为移动语义通常比复制语义更高效。例如，当你将一个对象传递给接受右值引用的函数时，你可以使用  &lt;code&gt;std::move&lt;/code&gt;  来传递对象的所有权，以便进行移动构造或移动赋值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免不必要的拷贝&lt;/strong&gt;：在某些情况下，对象的拷贝操作可能是不必要的，因为你知道这个对象在后续的使用中不再需要了。使用  &lt;code&gt;std::move&lt;/code&gt;  可以避免不必要的拷贝，从而提高程序的性能。例如，在将一个对象放入容器中时，你可以使用  &lt;code&gt;std::move&lt;/code&gt;  来移动对象，而不是复制对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上所述， &lt;code&gt;std::move&lt;/code&gt;  的主要作用是将左值转换为右值引用，以便进行移动语义的操作，并且可以避免不必要的拷贝，提高程序的性能。但需要注意的是，使用  &lt;code&gt;std::move&lt;/code&gt;  后，原始对象的状态会变为不确定的，因此在移动后，不要再对原始对象进行操作。&lt;/p&gt;
&lt;p&gt;除了上面 ABC 三项外，unique_ptr 的其余用法都与 auto_ptr 用法一致。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;构造
class Test &amp;#123;
public:
	Test() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;Test的构造函数...&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;
	~Test() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;Test的析构函数...&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;

	void doSomething() &amp;#123; cout &amp;lt;&amp;lt; &amp;quot;do something......&amp;quot; &amp;lt;&amp;lt; endl; &amp;#125;
&amp;#125;;


// 自定义一个内存释放其
class DestructTest &amp;#123;
	public:
	void operator()(Test *pt) &amp;#123;
		pt-&amp;gt;doSomething();
		delete pt;
	&amp;#125;
&amp;#125;;

// unique_ptr&amp;lt;T&amp;gt; up; 空的unique_ptr，可以指向类型为T的对象
unique_ptr&amp;lt;Test&amp;gt; t1;

// unique_ptr&amp;lt;T&amp;gt; up1(new T());	定义unique_ptr,同时指向类型为T的对象
unique_ptr&amp;lt;Test&amp;gt; t2(new Test);

// unique_ptr&amp;lt;T[]&amp;gt; up;	空的unique_ptr，可以指向类型为T[的数组对象
unique_ptr&amp;lt;int[]&amp;gt; t3;

// unique_ptr&amp;lt;T[]&amp;gt; up1(new T[]);	定义unique_ptr,同时指向类型为T的数组对象
unique_ptr&amp;lt;int[]&amp;gt; t4(new int[5]);

// unique_ptr&amp;lt;T, D&amp;gt; up();	空的unique_ptr，接受一个D类型的删除器D，使用D释放内存
unique_ptr&amp;lt;Test, DestructTest&amp;gt; t5;

// unique_ptr&amp;lt;T, D&amp;gt; up(new T());	定义unique_ptr,同时指向类型为T的对象，接受一个D类型的删除器D，使用删除器D来释放内存
unique_ptr&amp;lt;Test, DestructTest&amp;gt; t6(new Test);


赋值
unique_ptr&amp;lt;Test&amp;gt; t7(new Test);
unique_ptr&amp;lt;Test&amp;gt; t8(new Test);
t7 = std::move(t8);	// 必须使用移动语义，结果，t7的内存释放，t8的内存交给t7管理
t7-&amp;gt;doSomething();


主动释放对象
unique_ptr&amp;lt;Test&amp;gt; t9(new Test);
t9 = NULL;
t9 = nullptr;
t9.reset();

放弃对象的控制权

Test *t10 = t9.release();
重置
t9.reset(new Test);


auto_ptr 与 unique_ptr智能指针的内存管理陷阱
auto_ptr&amp;lt;string&amp;gt; p1;
string *str = new string(&amp;quot;智能指针的内存管理陷阱&amp;quot;);
p1.reset(str);	// p1托管str指针
&amp;#123;
	auto_ptr&amp;lt;string&amp;gt; p2;
	p2.reset(str);	// p2接管str指针时，会先取消p1的托管，然后再对str的托管
&amp;#125;

// 此时p1已经没有托管内容指针了，为NULL，在使用它就会内存报错！
cout &amp;lt;&amp;lt; &amp;quot;str：&amp;quot; &amp;lt;&amp;lt; *p1 &amp;lt;&amp;lt; endl;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://img-blog.csdnimg.cn/6b0a0e1ec3984107a1787671c7cad0fa.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;
&lt;p&gt;这是由于 auto_ptr 与 unique_ptr 的排他性所导致的！&lt;br /&gt;
&lt;strong&gt;为了解决这样的问题，我们可以使用 shared_ptr 指针指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;  是 C++ 标准库中的智能指针，用于管理动态分配的资源，并提供了共享所有权的语义。它允许多个智能指针共享同一个对象，而不会造成资源重复释放或悬空指针的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt;  的主要特点包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;共享所有权&lt;/strong&gt;：多个  &lt;code&gt;std::shared_ptr&lt;/code&gt;  对象可以指向同一个动态分配的对象，它们共享对该对象的所有权。只有当所有  &lt;code&gt;std::shared_ptr&lt;/code&gt;  对象都释放了对该对象的所有权后，该对象才会被销毁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用计数&lt;/strong&gt;： &lt;code&gt;std::shared_ptr&lt;/code&gt;  内部维护了一个引用计数，用于记录有多少个  &lt;code&gt;std::shared_ptr&lt;/code&gt;  对象共享同一个动态分配的对象。每次创建、拷贝、移动或销毁  &lt;code&gt;std::shared_ptr&lt;/code&gt;  对象时，引用计数都会相应地增加、减少或清零。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动释放资源&lt;/strong&gt;：当引用计数减少到零时， &lt;code&gt;std::shared_ptr&lt;/code&gt;  会自动释放所管理的资源，即调用动态分配对象的析构函数，并释放对象所占用的内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程安全的引用计数&lt;/strong&gt;： &lt;code&gt;std::shared_ptr&lt;/code&gt;  内部的引用计数是线程安全的，因此多个线程可以安全地共享同一个  &lt;code&gt;std::shared_ptr&lt;/code&gt;  对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环引用问题&lt;/strong&gt;： &lt;code&gt;std::shared_ptr&lt;/code&gt;  的共享所有权特性可能导致循环引用问题，即两个或多个对象相互持有对方的  &lt;code&gt;std::shared_ptr&lt;/code&gt;  对象，导致资源永远无法释放。为了避免这种情况，可以使用  &lt;code&gt;std::weak_ptr&lt;/code&gt;  来解决循环引用问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总的来说， &lt;code&gt;std::shared_ptr&lt;/code&gt;  是一种非常灵活和安全的智能指针，适用于多个对象需要共享同一个资源的情况。它提供了自动释放资源、引用计数、线程安全等特性，能够有效地管理动态分配的资源，并避免内存泄漏和悬空指针问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
class Person &amp;#123;
public:
	Person(int v) &amp;#123;
		this-&amp;gt;no = v;
		cout &amp;lt;&amp;lt; &amp;quot;构造函数 \t no = &amp;quot; &amp;lt;&amp;lt; this-&amp;gt;no &amp;lt;&amp;lt; endl;
	&amp;#125;

	~Person() &amp;#123;
		cout &amp;lt;&amp;lt; &amp;quot;析构函数 \t no = &amp;quot; &amp;lt;&amp;lt; this-&amp;gt;no &amp;lt;&amp;lt; endl;
	&amp;#125;

private:
	int no;
&amp;#125;;

// 仿函数，内存删除
class DestructPerson &amp;#123;
public:
	void operator() (Person *pt) &amp;#123;
		cout &amp;lt;&amp;lt; &amp;quot;DestructPerson...&amp;quot; &amp;lt;&amp;lt; endl;
		delete pt;
	&amp;#125;
&amp;#125;;


引用计数的使用

调用use_count函数可以获得当前托管指针的引用计数。

shared_ptr&amp;lt;Person&amp;gt; sp1;

shared_ptr&amp;lt;Person&amp;gt; sp2(new Person(2));

// 获取智能指针管控的共享指针的数量	use_count()：引用计数
cout &amp;lt;&amp;lt; &amp;quot;sp1	use_count() = &amp;quot; &amp;lt;&amp;lt; sp1.use_count() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;sp2	use_count() = &amp;quot; &amp;lt;&amp;lt; sp2.use_count() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;

// 共享
sp1 = sp2;

cout &amp;lt;&amp;lt; &amp;quot;sp1	use_count() = &amp;quot; &amp;lt;&amp;lt; sp1.use_count() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;sp2	use_count() = &amp;quot; &amp;lt;&amp;lt; sp2.use_count() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;

shared_ptr&amp;lt;Person&amp;gt; sp3(sp1);
cout &amp;lt;&amp;lt; &amp;quot;sp1	use_count() = &amp;quot; &amp;lt;&amp;lt; sp1.use_count() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;sp2	use_count() = &amp;quot; &amp;lt;&amp;lt; sp2.use_count() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;sp2	use_count() = &amp;quot; &amp;lt;&amp;lt; sp3.use_count() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; endl;


如上代码，sp1 = sp2; 和 shared_ptr&amp;lt; Person &amp;gt; sp3(sp1);就是在使用引用计数了。

sp1 = sp2; --&amp;gt; sp1和sp2共同托管同一个指针，所以他们的引用计数为2；
shared_ptr&amp;lt; Person &amp;gt; sp3(sp1); --&amp;gt; sp1和sp2和sp3共同托管同一个指针，所以他们的引用计数为3；
构造
 shared_ptr&amp;lt; T &amp;gt; sp1; 空的shared_ptr，可以指向类型为T的对象
shared_ptr&amp;lt;Person&amp;gt; sp1;
Person *person1 = new Person(1);
sp1.reset(person1);	// 托管person1

 shared_ptr&amp;lt; T &amp;gt; sp2(new T()); 定义shared_ptr,同时指向类型为T的对象
 shared_ptr&amp;lt;Person&amp;gt; sp2(new Person(2));
shared_ptr&amp;lt;Person&amp;gt; sp3(sp1);

shared_ptr&amp;lt;T[]&amp;gt; sp4; 空的shared_ptr，可以指向类型为T[]的数组对象 C++17后支持
shared_ptr&amp;lt;Person[]&amp;gt; sp4;


shared_ptr&amp;lt;T[]&amp;gt; sp5(new T[] &amp;#123; … &amp;#125;); 指向类型为T的数组对象 C++17后支持
shared_ptr&amp;lt;Person[]&amp;gt; sp5(new Person[5] &amp;#123; 3, 4, 5, 6, 7 &amp;#125;);



 shared_ptr&amp;lt; T &amp;gt; sp6(NULL, D()); //空的shared_ptr，接受一个D类型的删除器，使用D释放内存
 shared_ptr&amp;lt;Person&amp;gt; sp6(NULL, DestructPerson());

. shared_ptr&amp;lt; T &amp;gt; sp7(new T(), D()); //定义shared_ptr,指向类型为T的对象，接受一个D类型的删除器，使用D删除器来释放内存
shared_ptr&amp;lt;Person&amp;gt; sp7(new Person(8), DestructPerson());



                            
https://blog.csdn.net/cpp_learner/article/details/118912592
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;初始化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#初始化&#34;&gt;#&lt;/a&gt; 初始化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;1).&lt;/strong&gt; 方式一：构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shared_ptr&amp;lt;int&amp;gt; up1(new int(10));  // int(10) 的引用计数为1
shared_ptr&amp;lt;int&amp;gt; up2(up1);  // 使用智能指针up1构造up2, 此时int(10) 引用计数为2

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式二：使用 make_shared 初始化对象，分配内存效率更高 (推荐使用)&lt;br /&gt;
 make_shared 函数的主要功能是在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr; 用法：&lt;br /&gt;
make_shared &amp;lt;类型&amp;gt;(构造类型对象需要的参数列表);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shared_ptr&amp;lt;int&amp;gt; up3 = make_shared&amp;lt;int&amp;gt;(2); // 多个参数以逗号&#39;,&#39;隔开，最多接受十个
shared_ptr&amp;lt;string&amp;gt; up4 = make_shared&amp;lt;string&amp;gt;(&amp;quot;字符串&amp;quot;);
shared_ptr&amp;lt;Person&amp;gt; up5 = make_shared&amp;lt;Person&amp;gt;(9);

&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4 赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shared_ptrr&amp;lt;int&amp;gt; up1(new int(10));  // int(10) 的引用计数为1
shared_ptr&amp;lt;int&amp;gt; up2(new int(11));   // int(11) 的引用计数为1
up1 = up2;	// int(10) 的引用计数减1,计数归零内存释放，up2共享int(11)给up1, int(11)的引用计数为2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主动释放对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;shared_ptrr&amp;lt;int&amp;gt; up1(new int(10));
up1 = nullptr ;	// int(10) 的引用计数减1,计数归零内存释放 
// 或
up1 = NULL; // 作用同上 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p.reset() ; 将p重置为空指针，所管理对象引用计数 减1
p.reset(p1); 将p重置为p1（的值）,p 管控的对象计数减1，p接管对p1指针的管控
p.reset(p1,d); 将p重置为p1（的值），p 管控的对象计数减1并使用d作为删除器
p1是一个指针！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;交换&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p1 和 p2 是智能指针

std::swap(p1,p2); // 交换p1 和p2 管理的对象，原对象的引用计数不变
p1.swap(p2);    // 交换p1 和p2 管理的对象，原对象的引用计数不变
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shared_ptr使用陷阱&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#shared_ptr使用陷阱&#34;&gt;#&lt;/a&gt; shared_ptr 使用陷阱&lt;/h3&gt;
&lt;p&gt;shared_ptr 作为被管控的对象的成员时，小心因循环引用造成无法释放资源！&lt;/p&gt;
&lt;p&gt;如下代码：&lt;br /&gt;
Boy 类中有 Girl 的智能指针；&lt;br /&gt;
Girl 类中有 Boy 的智能指针；&lt;br /&gt;
当他们交叉互相持有对方的管理对象时…&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class Girl;

class Boy &amp;#123;
public:
	Boy() &amp;#123;
		cout &amp;lt;&amp;lt; &amp;quot;Boy 构造函数&amp;quot; &amp;lt;&amp;lt; endl;
	&amp;#125;

	~Boy() &amp;#123;
		cout &amp;lt;&amp;lt; &amp;quot;~Boy 析构函数&amp;quot; &amp;lt;&amp;lt; endl;
	&amp;#125;

	void setGirlFriend(shared_ptr&amp;lt;Girl&amp;gt; _girlFriend) &amp;#123;
		this-&amp;gt;girlFriend = _girlFriend;
	&amp;#125;

private:
	shared_ptr&amp;lt;Girl&amp;gt; girlFriend;
&amp;#125;;

class Girl &amp;#123;
public:
	Girl() &amp;#123;
		cout &amp;lt;&amp;lt; &amp;quot;Girl 构造函数&amp;quot; &amp;lt;&amp;lt; endl;
	&amp;#125;

	~Girl() &amp;#123;
		cout &amp;lt;&amp;lt; &amp;quot;~Girl 析构函数&amp;quot; &amp;lt;&amp;lt; endl;
	&amp;#125;

	void setBoyFriend(shared_ptr&amp;lt;Boy&amp;gt; _boyFriend) &amp;#123;
		this-&amp;gt;boyFriend = _boyFriend;
	&amp;#125;

private:
	shared_ptr&amp;lt;Boy&amp;gt; boyFriend;
&amp;#125;;


void useTrap() &amp;#123;
	shared_ptr&amp;lt;Boy&amp;gt; spBoy(new Boy());
	shared_ptr&amp;lt;Girl&amp;gt; spGirl(new Girl());

	// 陷阱用法
	spBoy-&amp;gt;setGirlFriend(spGirl);
	spGirl-&amp;gt;setBoyFriend(spBoy);
	// 此时boy和girl的引用计数都是2
&amp;#125;


int main(void) &amp;#123;
	useTrap();

	system(&amp;quot;pause&amp;quot;);
	return 0;
&amp;#125;


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码存在一个循环引用的问题，导致  &lt;code&gt;Boy&lt;/code&gt;  对象和  &lt;code&gt;Girl&lt;/code&gt;  对象互相持有对方的  &lt;code&gt;shared_ptr&lt;/code&gt; ，从而导致了内存泄漏，因为它们的引用计数永远不会变为 0。&lt;/p&gt;
&lt;p&gt;具体来说，当  &lt;code&gt;useTrap()&lt;/code&gt;  函数执行时，首先创建了一个  &lt;code&gt;shared_ptr&amp;lt;Boy&amp;gt;&lt;/code&gt;  对象  &lt;code&gt;spBoy&lt;/code&gt;  和一个  &lt;code&gt;shared_ptr&amp;lt;Girl&amp;gt;&lt;/code&gt;  对象  &lt;code&gt;spGirl&lt;/code&gt; 。然后，通过  &lt;code&gt;spBoy-&amp;gt;setGirlFriend(spGirl)&lt;/code&gt;  和  &lt;code&gt;spGirl-&amp;gt;setBoyFriend(spBoy)&lt;/code&gt;  分别将  &lt;code&gt;spGirl&lt;/code&gt;  和  &lt;code&gt;spBoy&lt;/code&gt;  传递给对方，这样就产生了循环引用的问题： &lt;code&gt;Boy&lt;/code&gt;  对象持有  &lt;code&gt;Girl&lt;/code&gt;  对象的  &lt;code&gt;shared_ptr&lt;/code&gt; ，而  &lt;code&gt;Girl&lt;/code&gt;  对象持有  &lt;code&gt;Boy&lt;/code&gt;  对象的  &lt;code&gt;shared_ptr&lt;/code&gt; 。因此，它们的引用计数都变成了 2，而不会减少到 0，导致它们的析构函数永远不会被调用，从而造成了内存泄漏。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，可以使用  &lt;code&gt;weak_ptr&lt;/code&gt;  来打破循环引用。 &lt;code&gt;weak_ptr&lt;/code&gt;  是  &lt;code&gt;shared_ptr&lt;/code&gt;  的一种弱引用，它可以监视  &lt;code&gt;shared_ptr&lt;/code&gt;  的生命周期，但不会影响其引用计数。因此，可以将  &lt;code&gt;Girl&lt;/code&gt;  类中的  &lt;code&gt;boyFriend&lt;/code&gt;  成员改为  &lt;code&gt;weak_ptr&amp;lt;Boy&amp;gt;&lt;/code&gt;  类型，从而避免循环引用的问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class Girl;

class Boy &amp;#123;
public:
    Boy() &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;Boy 构造函数&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    ~Boy() &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;~Boy 析构函数&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    void setGirlFriend(shared_ptr&amp;lt;Girl&amp;gt; _girlFriend) &amp;#123;
        this-&amp;gt;girlFriend = _girlFriend;
    &amp;#125;

private:
    weak_ptr&amp;lt;Girl&amp;gt; girlFriend;
&amp;#125;;

class Girl &amp;#123;
public:
    Girl() &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;Girl 构造函数&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    ~Girl() &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;~Girl 析构函数&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    void setBoyFriend(shared_ptr&amp;lt;Boy&amp;gt; _boyFriend) &amp;#123;
        this-&amp;gt;boyFriend = _boyFriend;
    &amp;#125;

private:
    weak_ptr&amp;lt;Boy&amp;gt; boyFriend;
&amp;#125;;


void useTrap() &amp;#123;
    shared_ptr&amp;lt;Boy&amp;gt; spBoy(new Boy());
    shared_ptr&amp;lt;Girl&amp;gt; spGirl(new Girl());

    // 陷阱用法
    spBoy-&amp;gt;setGirlFriend(spGirl);
    spGirl-&amp;gt;setBoyFriend(spBoy);
    // 此时boy和girl的引用计数都是2
&amp;#125;


int main(void) &amp;#123;
    useTrap();

    system(&amp;quot;pause&amp;quot;);
    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们执行 useTrap 函数时，注意，是没有结束此函数，boy 和 girl 指针其实是被两个智能指针托管的，所以他们的引用计数是 2&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://img-blog.csdnimg.cn/f00ef1a424b2427cb7817c146bf28abb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;
&lt;p&gt;useTrap 函数结束后，函数中定义的智能指针被清掉，boy 和 girl 指针的引用计数减 1，还剩下 1，对象中的智能指针还是托管他们的，所以函数结束后没有将 boy 和 gilr 指针释放的原因就是于此&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; data-src=&#34;https://img-blog.csdnimg.cn/cd962cb9e0ae4610bebb40da2133e8a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NwcF9sZWFybmVy,size_16,color_FFFFFF,t_70#pic_center&#34; alt=&#34;在这里插入图片描述&#34; /&gt;&lt;/p&gt;
&lt;p&gt;首先释放 spBoy，但是因为 girl 对象里面的智能指针还托管着 boy，boy 的引用计数为 2，所以释放 spBoy 时，引用计数减 1，boy 的引用计数为 1；&lt;br /&gt;
在释放 spGirl，girl 的引用计数减 1，为零，开始释放 girl 的内存，因为 girl 里面还包含有托管 boy 的智能指针对象，所以也会进行 boyFriend 的内存释放，boy 的引用计数减 1，为零，接着开始释放 boy 的内存。最终所有的内存都释放了。&lt;/p&gt;
&lt;p&gt;weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。 同时 weak_ptr 没有重载 * 和 -&amp;gt; 但可以使用 lock 获得一个可用的 shared_ptr 对象。&lt;/p&gt;
&lt;p&gt;弱指针的使用；&lt;br /&gt;
weak_ptr wpGirl_1; // 定义空的弱指针&lt;br /&gt;
 weak_ptr wpGirl_2 (spGirl); // 使用共享指针构造&lt;br /&gt;
 wpGirl_1 = spGirl; // 允许共享指针赋值给弱指针&lt;/p&gt;
&lt;p&gt;弱指针也可以获得引用计数；&lt;br /&gt;
wpGirl_1.use_count()&lt;/p&gt;
&lt;p&gt;您是对的。 &lt;code&gt;weak_ptr&lt;/code&gt;  是一种弱引用，它并不直接支持解引用操作 ( &lt;code&gt;*&lt;/code&gt;  和  &lt;code&gt;-&amp;gt;&lt;/code&gt; )，因为它并不拥有被指向对象的所有权。相反， &lt;code&gt;weak_ptr&lt;/code&gt;  主要用于监视由  &lt;code&gt;shared_ptr&lt;/code&gt;  管理的对象的生命周期，而不会增加对象的引用计数。&lt;/p&gt;
&lt;p&gt;要访问  &lt;code&gt;weak_ptr&lt;/code&gt;  所指向的对象，通常需要将  &lt;code&gt;weak_ptr&lt;/code&gt;  转换为  &lt;code&gt;shared_ptr&lt;/code&gt; 。可以通过  &lt;code&gt;lock()&lt;/code&gt;  成员函数将  &lt;code&gt;weak_ptr&lt;/code&gt;  转换为  &lt;code&gt;shared_ptr&lt;/code&gt; ，然后使用  &lt;code&gt;shared_ptr&lt;/code&gt;  的  &lt;code&gt;*&lt;/code&gt;  和  &lt;code&gt;-&amp;gt;&lt;/code&gt;  运算符来访问所指向的对象。&lt;/p&gt;
&lt;p&gt;以下是一个示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

int main() &amp;#123;
    shared_ptr&amp;lt;int&amp;gt; sp(new int(42));
    weak_ptr&amp;lt;int&amp;gt; wp = sp;

    // 尝试解引用 weak_ptr
    //int val = *wp;  // 错误：weak_ptr 不支持直接解引用
    //cout &amp;lt;&amp;lt; &amp;quot;Value: &amp;quot; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; endl;

    // 尝试通过 -&amp;gt; 运算符访问 weak_ptr 所指向的对象
    //int val2 = wp-&amp;gt;getValue(); // 错误：weak_ptr 不支持直接使用 -&amp;gt; 运算符

    // 将 weak_ptr 转换为 shared_ptr
    shared_ptr&amp;lt;int&amp;gt; sp2 = wp.lock();
    if (sp2) &amp;#123;
        // 成功获取 shared_ptr，现在可以使用 * 和 -&amp;gt; 运算符访问所指向的对象
        int val3 = *sp2;
        cout &amp;lt;&amp;lt; &amp;quot;Value: &amp;quot; &amp;lt;&amp;lt; val3 &amp;lt;&amp;lt; endl;
    &amp;#125; else &amp;#123;
        cout &amp;lt;&amp;lt; &amp;quot;The shared_ptr is expired.&amp;quot; &amp;lt;&amp;lt; endl;
    &amp;#125;

    return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们使用了  &lt;code&gt;lock()&lt;/code&gt;  函数将  &lt;code&gt;weak_ptr&lt;/code&gt;  转换为  &lt;code&gt;shared_ptr&lt;/code&gt; ，然后使用  &lt;code&gt;shared_ptr&lt;/code&gt;  的  &lt;code&gt;*&lt;/code&gt;  运算符来解引用  &lt;code&gt;shared_ptr&lt;/code&gt;  对象并访问所指向的对象的值。这样做的好处是，在转换为  &lt;code&gt;shared_ptr&lt;/code&gt;  时，我们同时增加了被指向对象的引用计数，确保在  &lt;code&gt;shared_ptr&lt;/code&gt;  存活期间对象不会被销毁。&lt;/p&gt;
&lt;p&gt;expired 函数的用法&lt;br /&gt;
应评论区某位朋友的要求，现在加上 weak_ptr 指针的 expired 函数的用法！&lt;/p&gt;
&lt;p&gt;expired：判断当前 weak_ptr 智能指针是否还有托管的对象，有则返回 false，无则返回 true&lt;/p&gt;
&lt;p&gt;如果返回 true，等价于 use_count () == 0，即已经没有托管的对象了；当然，可能还有析构函数进行释放内存，但此对象的析构已经临近（或可能已发生）。&lt;/p&gt;
&lt;p&gt;示例&lt;br /&gt;
演示如何用 expired 检查指针的合法性。&lt;br /&gt;
在网上找了一段代码，加上自己的注释理解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

std::weak_ptr&amp;lt;int&amp;gt; gw;

void f() &amp;#123;

	// expired：判断当前智能指针是否还有托管的对象，有则返回false，无则返回true
	if (!gw.expired()) &amp;#123;
		std::cout &amp;lt;&amp;lt; &amp;quot;gw is valid\n&amp;quot;;	// 有效的，还有托管的指针
	&amp;#125; else &amp;#123;
		std::cout &amp;lt;&amp;lt; &amp;quot;gw is expired\n&amp;quot;;	// 过期的，没有托管的指针
	&amp;#125;
&amp;#125;

int main() &amp;#123;
	&amp;#123;
		auto sp = std::make_shared&amp;lt;int&amp;gt;(42);
		gw = sp;

		f();
	&amp;#125;

	// 当&amp;#123; &amp;#125;体中的指针生命周期结束后，再来判断其是否还有托管的指针
	f();

	return 0;
&amp;#125;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;六、智能指针的使用陷阱&lt;br /&gt;
不要把一个原生指针给多个智能指针管理；&lt;/p&gt;
&lt;p&gt;int *x = new int(10);&lt;br /&gt;
unique_ptr&amp;lt; int &amp;gt; up1(x);&lt;br /&gt;
unique_ptr&amp;lt; int &amp;gt; up2(x);&lt;br /&gt;
// 警告！以上代码使 up1 up2 指向同一个内存，非常危险&lt;br /&gt;
或以下形式：&lt;br /&gt;
up1.reset(x);&lt;br /&gt;
up2.reset(x);&lt;/p&gt;
&lt;p&gt;记得使用 u.release () 的返回值；&lt;br /&gt;
 在调用 u.release () 时是不会释放 u 所指的内存的，这时返回值就是对这块内存的唯一索引，如果没有使用这个返回值释放内存或是保存起来，这块内存就泄漏了.&lt;/p&gt;
&lt;p&gt;禁止 delete 智能指针 get 函数返回的指针；&lt;br /&gt;
 如果我们主动释放掉 get 函数获得的指针，那么智能 指针内部的指针就变成野指针了，析构时造成重复释放，带来严重后果！&lt;/p&gt;
&lt;p&gt;禁止用任何类型智能指针 get 函数返回的指针去初始化另外一个智能指针！&lt;br /&gt;
shared_ptr&amp;lt; int &amp;gt; sp1(new int(10));&lt;br /&gt;
// 一个典型的错误用法 shared_ptr&amp;lt;int&amp;gt; sp4 (sp1.get ());&lt;br /&gt;
————————————————&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原文链接：&lt;a href=&#34;https://blog.csdn.net/cpp_learner/article/details/118912592&#34;&gt;https://blog.csdn.net/cpp_learner/article/details/118912592&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;智能指针虽然使用起来很方便，但是要注意使用智能指针的一些陷阱，否则会造成严重的内存报错或者内存泄露等问题！&lt;/p&gt;
&lt;p&gt;某最大矩阵写的暴力&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;vector&amp;gt;
using namespace std;

class Solution &amp;#123;
public:
    int maximalSquare(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; matrix) &amp;#123;
        int n = matrix.size();
        if (n == 0) return 0;
        int m = matrix[0].size();
        if (m == 0) return 0;

        // 将字符矩阵转换为整数矩阵
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; f(n + 1, vector&amp;lt;int&amp;gt;(m + 1, 0));
        for (int i = 1; i &amp;lt;= n; i++)
            for (int j = 1; j &amp;lt;= m; j++)
                f[i][j] = matrix[i - 1][j - 1] - &#39;0&#39;;

        int ans = 0;

        // 先更新前缀和
        for (int i = 1; i &amp;lt;= n; i++)
            for (int j = 1; j &amp;lt;= m; j++)
                f[i][j] += f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1];

        for (int i = 1; i &amp;lt;= n; i++) &amp;#123;
            for (int j = 1; j &amp;lt;= m; j++) &amp;#123;
                // 确定一个点，枚举边长
                for (int k = 1; k &amp;lt;= min(n - i + 1, m - j + 1); k++) &amp;#123;
                    // 枚举边长
                    int x1 = i, x2 = i + k - 1, y1 = j, y2 = j + k - 1;
                    // 确定四个点
                    int sum = f[x2][y2] - f[x1 - 1][y2] - f[x2][y1 - 1] + f[x1 - 1][y1 - 1];
                    // 计算面积
                    if (sum == k * k)
                        ans = max(ans, sum);
                    if (sum != k * k)
                        break;
                    // 更新答案
                &amp;#125;
            &amp;#125;
        &amp;#125;

        return ans;
    &amp;#125;
&amp;#125;;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;神奇的dp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#神奇的dp&#34;&gt;#&lt;/a&gt; 神奇的 DP&lt;/h3&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lysistic.github.io/2024/03/03/hello-world/</guid>
            <title>Hello World</title>
            <link>https://lysistic.github.io/2024/03/03/hello-world/</link>
            <pubDate>Sun, 03 Mar 2024 02:01:38 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Welcome to &lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&#34;https://hexo.io/docs/&#34;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&#34;https://hexo.io/docs/troubleshooting.html&#34;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&#34;https://github.com/hexojs/hexo/issues&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;quick-start&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#quick-start&#34;&gt;#&lt;/a&gt; Quick Start&lt;/h2&gt;
&lt;h3 id=&#34;create-a-new-post&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#create-a-new-post&#34;&gt;#&lt;/a&gt; Create a new post&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo new &lt;span class=&#34;token string&#34;&gt;&#34;My New Post&#34;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/writing.html&#34;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;run-server&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#run-server&#34;&gt;#&lt;/a&gt; Run server&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo server&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/server.html&#34;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;generate-static-files&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#generate-static-files&#34;&gt;#&lt;/a&gt; Generate static files&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo generate&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/generating.html&#34;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploy-to-remote-sites&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#deploy-to-remote-sites&#34;&gt;#&lt;/a&gt; Deploy to remote sites&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo deploy&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;a href=&#34;https://hexo.io/docs/one-command-deployment.html&#34;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lysistic.github.io/2024/03/03/git-learn/</guid>
            <title>git-learn</title>
            <link>https://lysistic.github.io/2024/03/03/git-learn/</link>
            <pubDate>Sun, 03 Mar 2024 00:14:01 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;WorkSpace: 工作区  index/Stage: 暂存区 Repository: 仓库区 Remote: 远程仓库&lt;/p&gt;
&lt;h2 id=&#34;git-init-初始化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#git-init-初始化&#34;&gt;#&lt;/a&gt;  &lt;code&gt;git init 初始化&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;.git  Git 用来跟踪管理版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git add readme.txt 添加文本&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git commit -m &#39;hello world&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git status 查看是否还有文件未提交&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git diff readme.txt 查看修改&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git log 查看历史日志&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git log -pretty=oneline 单行显示&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;版本回退&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#版本回退&#34;&gt;#&lt;/a&gt; 版本回退&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git reset --hard HEAD^ 回退一个版本&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset --hard HEAD^^ 回退两个版本&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset --hard HEAD~100 回退到前100个版本&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reset --hard 版本号&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git reflog 获取各个版本版本号&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作区：就是你在电脑上看到的目录，比如目录下 testgit 里的文件 (.git 隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。&lt;/li&gt;
&lt;li&gt;版本库 (Repository)：工作区有一个隐藏目录.git, 这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是 stage (暂存区)，还有 Git 为我们自动创建了第一个分支 master, 以及指向 master 的一个指针 HEAD。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git commit 一次性提交&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout --filename &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eg: git checkout --readme.txt 撤销提交&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout --file_deleted 恢复被撤销的文件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git remote add origin url&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git push -u origin master 推送本地仓库master分支&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;先本地commit 再 git push origin master&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone url&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout -b dev 创建并切换分支&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch 查看当前分支&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;-b 参数表示切换&lt;/p&gt;
&lt;p&gt;创建分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切换分支&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git checkout dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge dev 合并指定分支到主分支上&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch -d dev&lt;/code&gt;  删除 dev 分支&lt;/p&gt;
&lt;p&gt;conclusion&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;查看分支 git branch&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;创建分支 git branch name&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;切换分支 git checkout name&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;创建+切换分支 git checkout -b name&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;合并某分支到当前分支 git merge name&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;删除分支 git branch -d name&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git merge --no-ff -m &amp;quot;eaewea with no-ff&amp;quot; dev 禁用fast forward&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git log --graph --pretty=oneline --abbrev-commit&lt;/code&gt;  是一个 Git 命令，用于查看提交历史，并以图形化的方式显示提交历史，并指定了显示格式和提交 ID 的缩写。&lt;/p&gt;
&lt;p&gt;解读这个命令的各个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt; : 显示提交历史记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--graph&lt;/code&gt; : 使用图形化的方式显示提交历史。这会在输出中添加一些字符来表示提交历史的分支和合并关系，使其更易于理解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pretty=oneline&lt;/code&gt; : 指定输出格式为单行显示。这会以紧凑的方式显示提交历史，每个提交占据一行，每行显示一个提交的摘要信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--abbrev-commit&lt;/code&gt; : 缩写提交 ID。这会使提交 ID 的长度缩短，只显示前几个字符，以提高显示的紧凑性和可读性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git stash 将当前工作现场隐藏起来&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt;  是干净的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git checkout -b filename 创建bug修复分支&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bug 修复后，切换到 master 分支，完成合并，再删除 bug 修复分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git stash list&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git stash apply 恢复&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git stash drop 删除&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;或者直接 git stash pop 恢复的同时删除&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git remote 查看远程仓库的信息&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git remote -v 查看远程仓库的详细信息&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push origin master&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git push origin dev 推送不同分支 多台机器合作&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git branch --set-upsteam dev origin/dev 指定本地dev分支与远程origin/dev分支的联系&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[&lt;a href=&#34;https://www.cnblogs.com/tugenhua0707/p/4050072.html&#34;&gt;Git 使用教程 - 龙恩 0707 - 博客园 (cnblogs.com)&lt;/a&gt;](&lt;a href=&#34;https://www.cnblogs.com/tugenhua0707/p/4050072.html&#34;&gt;https://www.cnblogs.com/tugenhua0707/p/4050072.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&#34;&gt;常用 Git 命令清单 - 阮一峰的网络日志 (ruanyifeng.com)&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一、新建代码库

# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name] # 下载一个项目和它的整个代码历史
$ git clone [url]

二、配置
# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global] # 设置提交代码时的用户信息
$ git config [--global] user.name &amp;quot;[name]&amp;quot;
$ git config [--global] user.email &amp;quot;[email address]&amp;quot;

三、增加/删除文件
# 添加指定文件到暂存区
$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录
$ git add [dir] # 添加当前目录的所有文件到暂存区
$ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]

四、代码提交
# 提交暂存区到仓库区
$ git commit -m [message] # 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...

五、分支
# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name] # 新建一个分支，并切换到该分支
$ git checkout -b [branch] # 新建一个分支，指向指定commit
$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区
$ git checkout [branch-name] # 切换到上一个分支
$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支
$ git merge [branch] # 选择一个commit，合并进当前分支
$ git cherry-pick [commit] # 删除分支
$ git branch -d [branch-name] # 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]

六、标签
# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag] # 新建一个tag在指定commit
$ git tag [tag] [commit] # 删除本地tag
$ git tag -d [tag] # 删除远程tag
$ git push origin :refs/tags/[tagName] # 查看tag信息
$ git show [tag] # 提交指定tag
$ git push [remote] [tag] # 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]

七、查看信息
# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&amp;quot;提交说明&amp;quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file] # 显示指定文件相关的每一次diff
$ git log -p [file] # 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file] # 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码
$ git diff --shortstat &amp;quot;@&amp;#123;0 day ago&amp;#125;&amp;quot; # 显示某次提交的元数据和内容变化
$ git show [commit] # 显示某次提交发生变化的文件
$ git show --name-only [commit] # 显示某次提交时，某个文件的内容
$ git show [commit]:[filename] # 显示当前分支的最近几次提交
$ git reflog

八、远程同步
# 下载远程仓库的所有变动
$ git fetch [remote] # 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote] # 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch] # 上传本地指定分支到远程仓库
$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all

九、撤销
# 恢复暂存区的指定文件到工作区
$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区
$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop

&lt;/code&gt;&lt;/pre&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://lysistic.github.io/2024/02/12/my-first-article/</guid>
            <title>my first article</title>
            <link>https://lysistic.github.io/2024/02/12/my-first-article/</link>
            <pubDate>Mon, 12 Feb 2024 18:14:24 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;this-is-my-first-blog&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#this-is-my-first-blog&#34;&gt;#&lt;/a&gt; This is my first blog.&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Hello World！&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
